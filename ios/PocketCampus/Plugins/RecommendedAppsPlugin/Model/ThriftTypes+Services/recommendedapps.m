/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"


#import "recommendedapps.h"

@implementation RecommendedApp

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAppStoreQuery: (NSString *) appStoreQuery appName: (NSString *) appName appDescription: (NSString *) appDescription appOpenURLPattern: (NSString *) appOpenURLPattern appLogoURL: (NSString *) appLogoURL
{
  self = [super init];
  __appStoreQuery = [appStoreQuery retain_stub];
  __appStoreQuery_isset = YES;
  __appName = [appName retain_stub];
  __appName_isset = YES;
  __appDescription = [appDescription retain_stub];
  __appDescription_isset = YES;
  __appOpenURLPattern = [appOpenURLPattern retain_stub];
  __appOpenURLPattern_isset = YES;
  __appLogoURL = [appLogoURL retain_stub];
  __appLogoURL_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"appStoreQuery"])
  {
    __appStoreQuery = [[decoder decodeObjectForKey: @"appStoreQuery"] retain_stub];
    __appStoreQuery_isset = YES;
  }
  if ([decoder containsValueForKey: @"appName"])
  {
    __appName = [[decoder decodeObjectForKey: @"appName"] retain_stub];
    __appName_isset = YES;
  }
  if ([decoder containsValueForKey: @"appDescription"])
  {
    __appDescription = [[decoder decodeObjectForKey: @"appDescription"] retain_stub];
    __appDescription_isset = YES;
  }
  if ([decoder containsValueForKey: @"appOpenURLPattern"])
  {
    __appOpenURLPattern = [[decoder decodeObjectForKey: @"appOpenURLPattern"] retain_stub];
    __appOpenURLPattern_isset = YES;
  }
  if ([decoder containsValueForKey: @"appLogoURL"])
  {
    __appLogoURL = [[decoder decodeObjectForKey: @"appLogoURL"] retain_stub];
    __appLogoURL_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__appStoreQuery_isset)
  {
    [encoder encodeObject: __appStoreQuery forKey: @"appStoreQuery"];
  }
  if (__appName_isset)
  {
    [encoder encodeObject: __appName forKey: @"appName"];
  }
  if (__appDescription_isset)
  {
    [encoder encodeObject: __appDescription forKey: @"appDescription"];
  }
  if (__appOpenURLPattern_isset)
  {
    [encoder encodeObject: __appOpenURLPattern forKey: @"appOpenURLPattern"];
  }
  if (__appLogoURL_isset)
  {
    [encoder encodeObject: __appLogoURL forKey: @"appLogoURL"];
  }
}

- (void) dealloc
{
  [__appStoreQuery release_stub];
  [__appName release_stub];
  [__appDescription release_stub];
  [__appOpenURLPattern release_stub];
  [__appLogoURL release_stub];
  [super dealloc_stub];
}

- (NSString *) appStoreQuery {
  return [[__appStoreQuery retain_stub] autorelease_stub];
}

- (void) setAppStoreQuery: (NSString *) appStoreQuery {
  [appStoreQuery retain_stub];
  [__appStoreQuery release_stub];
  __appStoreQuery = appStoreQuery;
  __appStoreQuery_isset = YES;
}

- (BOOL) appStoreQueryIsSet {
  return __appStoreQuery_isset;
}

- (void) unsetAppStoreQuery {
  [__appStoreQuery release_stub];
  __appStoreQuery = nil;
  __appStoreQuery_isset = NO;
}

- (NSString *) appName {
  return [[__appName retain_stub] autorelease_stub];
}

- (void) setAppName: (NSString *) appName {
  [appName retain_stub];
  [__appName release_stub];
  __appName = appName;
  __appName_isset = YES;
}

- (BOOL) appNameIsSet {
  return __appName_isset;
}

- (void) unsetAppName {
  [__appName release_stub];
  __appName = nil;
  __appName_isset = NO;
}

- (NSString *) appDescription {
  return [[__appDescription retain_stub] autorelease_stub];
}

- (void) setAppDescription: (NSString *) appDescription {
  [appDescription retain_stub];
  [__appDescription release_stub];
  __appDescription = appDescription;
  __appDescription_isset = YES;
}

- (BOOL) appDescriptionIsSet {
  return __appDescription_isset;
}

- (void) unsetAppDescription {
  [__appDescription release_stub];
  __appDescription = nil;
  __appDescription_isset = NO;
}

- (NSString *) appOpenURLPattern {
  return [[__appOpenURLPattern retain_stub] autorelease_stub];
}

- (void) setAppOpenURLPattern: (NSString *) appOpenURLPattern {
  [appOpenURLPattern retain_stub];
  [__appOpenURLPattern release_stub];
  __appOpenURLPattern = appOpenURLPattern;
  __appOpenURLPattern_isset = YES;
}

- (BOOL) appOpenURLPatternIsSet {
  return __appOpenURLPattern_isset;
}

- (void) unsetAppOpenURLPattern {
  [__appOpenURLPattern release_stub];
  __appOpenURLPattern = nil;
  __appOpenURLPattern_isset = NO;
}

- (NSString *) appLogoURL {
  return [[__appLogoURL retain_stub] autorelease_stub];
}

- (void) setAppLogoURL: (NSString *) appLogoURL {
  [appLogoURL retain_stub];
  [__appLogoURL release_stub];
  __appLogoURL = appLogoURL;
  __appLogoURL_isset = YES;
}

- (BOOL) appLogoURLIsSet {
  return __appLogoURL_isset;
}

- (void) unsetAppLogoURL {
  [__appLogoURL release_stub];
  __appLogoURL = nil;
  __appLogoURL_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppStoreQuery: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppDescription: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppOpenURLPattern: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppLogoURL: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RecommendedApp"];
  if (__appStoreQuery_isset) {
    if (__appStoreQuery != nil) {
      [outProtocol writeFieldBeginWithName: @"appStoreQuery" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __appStoreQuery];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appName_isset) {
    if (__appName != nil) {
      [outProtocol writeFieldBeginWithName: @"appName" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __appName];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appDescription_isset) {
    if (__appDescription != nil) {
      [outProtocol writeFieldBeginWithName: @"appDescription" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __appDescription];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appOpenURLPattern_isset) {
    if (__appOpenURLPattern != nil) {
      [outProtocol writeFieldBeginWithName: @"appOpenURLPattern" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __appOpenURLPattern];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appLogoURL_isset) {
    if (__appLogoURL != nil) {
      [outProtocol writeFieldBeginWithName: @"appLogoURL" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __appLogoURL];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__appStoreQuery_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'appStoreQuery' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RecommendedApp("];
  [ms appendString: @"appStoreQuery:"];
  [ms appendFormat: @"\"%@\"", __appStoreQuery];
  [ms appendString: @",appName:"];
  [ms appendFormat: @"\"%@\"", __appName];
  [ms appendString: @",appDescription:"];
  [ms appendFormat: @"\"%@\"", __appDescription];
  [ms appendString: @",appOpenURLPattern:"];
  [ms appendFormat: @"\"%@\"", __appOpenURLPattern];
  [ms appendString: @",appLogoURL:"];
  [ms appendFormat: @"\"%@\"", __appLogoURL];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation RecommendedAppCategory

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithCategoryName: (NSString *) categoryName categoryLogoURL: (NSString *) categoryLogoURL categoryDescription: (NSString *) categoryDescription appIds: (NSMutableArray *) appIds
{
  self = [super init];
  __categoryName = [categoryName retain_stub];
  __categoryName_isset = YES;
  __categoryLogoURL = [categoryLogoURL retain_stub];
  __categoryLogoURL_isset = YES;
  __categoryDescription = [categoryDescription retain_stub];
  __categoryDescription_isset = YES;
  __appIds = [appIds retain_stub];
  __appIds_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"categoryName"])
  {
    __categoryName = [[decoder decodeObjectForKey: @"categoryName"] retain_stub];
    __categoryName_isset = YES;
  }
  if ([decoder containsValueForKey: @"categoryLogoURL"])
  {
    __categoryLogoURL = [[decoder decodeObjectForKey: @"categoryLogoURL"] retain_stub];
    __categoryLogoURL_isset = YES;
  }
  if ([decoder containsValueForKey: @"categoryDescription"])
  {
    __categoryDescription = [[decoder decodeObjectForKey: @"categoryDescription"] retain_stub];
    __categoryDescription_isset = YES;
  }
  if ([decoder containsValueForKey: @"appIds"])
  {
    __appIds = [[decoder decodeObjectForKey: @"appIds"] retain_stub];
    __appIds_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__categoryName_isset)
  {
    [encoder encodeObject: __categoryName forKey: @"categoryName"];
  }
  if (__categoryLogoURL_isset)
  {
    [encoder encodeObject: __categoryLogoURL forKey: @"categoryLogoURL"];
  }
  if (__categoryDescription_isset)
  {
    [encoder encodeObject: __categoryDescription forKey: @"categoryDescription"];
  }
  if (__appIds_isset)
  {
    [encoder encodeObject: __appIds forKey: @"appIds"];
  }
}

- (void) dealloc
{
  [__categoryName release_stub];
  [__categoryLogoURL release_stub];
  [__categoryDescription release_stub];
  [__appIds release_stub];
  [super dealloc_stub];
}

- (NSString *) categoryName {
  return [[__categoryName retain_stub] autorelease_stub];
}

- (void) setCategoryName: (NSString *) categoryName {
  [categoryName retain_stub];
  [__categoryName release_stub];
  __categoryName = categoryName;
  __categoryName_isset = YES;
}

- (BOOL) categoryNameIsSet {
  return __categoryName_isset;
}

- (void) unsetCategoryName {
  [__categoryName release_stub];
  __categoryName = nil;
  __categoryName_isset = NO;
}

- (NSString *) categoryLogoURL {
  return [[__categoryLogoURL retain_stub] autorelease_stub];
}

- (void) setCategoryLogoURL: (NSString *) categoryLogoURL {
  [categoryLogoURL retain_stub];
  [__categoryLogoURL release_stub];
  __categoryLogoURL = categoryLogoURL;
  __categoryLogoURL_isset = YES;
}

- (BOOL) categoryLogoURLIsSet {
  return __categoryLogoURL_isset;
}

- (void) unsetCategoryLogoURL {
  [__categoryLogoURL release_stub];
  __categoryLogoURL = nil;
  __categoryLogoURL_isset = NO;
}

- (NSString *) categoryDescription {
  return [[__categoryDescription retain_stub] autorelease_stub];
}

- (void) setCategoryDescription: (NSString *) categoryDescription {
  [categoryDescription retain_stub];
  [__categoryDescription release_stub];
  __categoryDescription = categoryDescription;
  __categoryDescription_isset = YES;
}

- (BOOL) categoryDescriptionIsSet {
  return __categoryDescription_isset;
}

- (void) unsetCategoryDescription {
  [__categoryDescription release_stub];
  __categoryDescription = nil;
  __categoryDescription_isset = NO;
}

- (NSMutableArray *) appIds {
  return [[__appIds retain_stub] autorelease_stub];
}

- (void) setAppIds: (NSMutableArray *) appIds {
  [appIds retain_stub];
  [__appIds release_stub];
  __appIds = appIds;
  __appIds_isset = YES;
}

- (BOOL) appIdsIsSet {
  return __appIds_isset;
}

- (void) unsetAppIds {
  [__appIds release_stub];
  __appIds = nil;
  __appIds_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCategoryName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCategoryLogoURL: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCategoryDescription: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            int32_t _elem2 = [inProtocol readI32];
            [fieldValue addObject: [NSNumber numberWithLong: _elem2]];
          }
          [inProtocol readListEnd];
          [self setAppIds: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RecommendedAppCategory"];
  if (__categoryName_isset) {
    if (__categoryName != nil) {
      [outProtocol writeFieldBeginWithName: @"categoryName" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __categoryName];
      [outProtocol writeFieldEnd];
    }
  }
  if (__categoryLogoURL_isset) {
    if (__categoryLogoURL != nil) {
      [outProtocol writeFieldBeginWithName: @"categoryLogoURL" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __categoryLogoURL];
      [outProtocol writeFieldEnd];
    }
  }
  if (__categoryDescription_isset) {
    if (__categoryDescription != nil) {
      [outProtocol writeFieldBeginWithName: @"categoryDescription" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __categoryDescription];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appIds_isset) {
    if (__appIds != nil) {
      [outProtocol writeFieldBeginWithName: @"appIds" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_I32 size: [__appIds count]];
        int idx4;
        for (idx4 = 0; idx4 < [__appIds count]; idx4++)
        {
          [outProtocol writeI32: [[__appIds objectAtIndex: idx4] longValue]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__categoryName_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'categoryName' is not set."];
  }
  if (!__categoryDescription_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'categoryDescription' is not set."];
  }
  if (!__appIds_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'appIds' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RecommendedAppCategory("];
  [ms appendString: @"categoryName:"];
  [ms appendFormat: @"\"%@\"", __categoryName];
  [ms appendString: @",categoryLogoURL:"];
  [ms appendFormat: @"\"%@\"", __categoryLogoURL];
  [ms appendString: @",categoryDescription:"];
  [ms appendFormat: @"\"%@\"", __categoryDescription];
  [ms appendString: @",appIds:"];
  [ms appendFormat: @"%@", __appIds];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation RecommendedAppsResponse

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStatus: (int) status categories: (NSMutableArray *) categories apps: (NSMutableDictionary *) apps
{
  self = [super init];
  __status = status;
  __status_isset = YES;
  __categories = [categories retain_stub];
  __categories_isset = YES;
  __apps = [apps retain_stub];
  __apps_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [decoder decodeIntForKey: @"status"];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"categories"])
  {
    __categories = [[decoder decodeObjectForKey: @"categories"] retain_stub];
    __categories_isset = YES;
  }
  if ([decoder containsValueForKey: @"apps"])
  {
    __apps = [[decoder decodeObjectForKey: @"apps"] retain_stub];
    __apps_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__status_isset)
  {
    [encoder encodeInt: __status forKey: @"status"];
  }
  if (__categories_isset)
  {
    [encoder encodeObject: __categories forKey: @"categories"];
  }
  if (__apps_isset)
  {
    [encoder encodeObject: __apps forKey: @"apps"];
  }
}

- (void) dealloc
{
  [__categories release_stub];
  [__apps release_stub];
  [super dealloc_stub];
}

- (int) status {
  return __status;
}

- (void) setStatus: (int) status {
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  __status_isset = NO;
}

- (NSMutableArray *) categories {
  return [[__categories retain_stub] autorelease_stub];
}

- (void) setCategories: (NSMutableArray *) categories {
  [categories retain_stub];
  [__categories release_stub];
  __categories = categories;
  __categories_isset = YES;
}

- (BOOL) categoriesIsSet {
  return __categories_isset;
}

- (void) unsetCategories {
  [__categories release_stub];
  __categories = nil;
  __categories_isset = NO;
}

- (NSMutableDictionary *) apps {
  return [[__apps retain_stub] autorelease_stub];
}

- (void) setApps: (NSMutableDictionary *) apps {
  [apps retain_stub];
  [__apps release_stub];
  __apps = apps;
  __apps_isset = YES;
}

- (BOOL) appsIsSet {
  return __apps_isset;
}

- (void) unsetApps {
  [__apps release_stub];
  __apps = nil;
  __apps_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setStatus: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size5;
          [inProtocol readListBeginReturningElementType: NULL size: &_size5];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size5];
          int _i6;
          for (_i6 = 0; _i6 < _size5; ++_i6)
          {
            RecommendedAppCategory *_elem7 = [[RecommendedAppCategory alloc] init];
            [_elem7 read: inProtocol];
            [fieldValue addObject: _elem7];
            [_elem7 release_stub];
          }
          [inProtocol readListEnd];
          [self setCategories: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_MAP) {
          int _size8;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size8];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size8];
          int _i9;
          for (_i9 = 0; _i9 < _size8; ++_i9)
          {
            int32_t _key10 = [inProtocol readI32];
            RecommendedApp *_val11 = [[RecommendedApp alloc] init];
            [_val11 read: inProtocol];
            [fieldValue setObject: _val11 forKey: [NSNumber numberWithLong: _key10]];
            [_val11 release_stub];
          }
          [inProtocol readMapEnd];
          [self setApps: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RecommendedAppsResponse"];
  if (__status_isset) {
    [outProtocol writeFieldBeginWithName: @"status" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __status];
    [outProtocol writeFieldEnd];
  }
  if (__categories_isset) {
    if (__categories != nil) {
      [outProtocol writeFieldBeginWithName: @"categories" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__categories count]];
        int idx13;
        for (idx13 = 0; idx13 < [__categories count]; idx13++)
        {
          [[__categories objectAtIndex: idx13] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__apps_isset) {
    if (__apps != nil) {
      [outProtocol writeFieldBeginWithName: @"apps" type: TType_MAP fieldID: 3];
      {
        [outProtocol writeMapBeginWithKeyType: TType_I32 valueType: TType_STRUCT size: [__apps count]];
        NSEnumerator * _iter14 = [__apps keyEnumerator];
        id key15;
        while ((key15 = [_iter14 nextObject]))
        {
          [outProtocol writeI32: [key15 longValue]];
          [[__apps objectForKey: key15] write: outProtocol];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__status_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'status' is not set."];
  }
  if (!__categories_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'categories' is not set."];
  }
  if (!__apps_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'apps' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RecommendedAppsResponse("];
  [ms appendString: @"status:"];
  [ms appendFormat: @"%i", __status];
  [ms appendString: @",categories:"];
  [ms appendFormat: @"%@", __categories];
  [ms appendString: @",apps:"];
  [ms appendFormat: @"%@", __apps];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation RecommendedAppsRequest

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithLanguage: (NSString *) language appStore: (int) appStore
{
  self = [super init];
  __language = [language retain_stub];
  __language_isset = YES;
  __appStore = appStore;
  __appStore_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"language"])
  {
    __language = [[decoder decodeObjectForKey: @"language"] retain_stub];
    __language_isset = YES;
  }
  if ([decoder containsValueForKey: @"appStore"])
  {
    __appStore = [decoder decodeIntForKey: @"appStore"];
    __appStore_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__language_isset)
  {
    [encoder encodeObject: __language forKey: @"language"];
  }
  if (__appStore_isset)
  {
    [encoder encodeInt: __appStore forKey: @"appStore"];
  }
}

- (void) dealloc
{
  [__language release_stub];
  [super dealloc_stub];
}

- (NSString *) language {
  return [[__language retain_stub] autorelease_stub];
}

- (void) setLanguage: (NSString *) language {
  [language retain_stub];
  [__language release_stub];
  __language = language;
  __language_isset = YES;
}

- (BOOL) languageIsSet {
  return __language_isset;
}

- (void) unsetLanguage {
  [__language release_stub];
  __language = nil;
  __language_isset = NO;
}

- (int) appStore {
  return __appStore;
}

- (void) setAppStore: (int) appStore {
  __appStore = appStore;
  __appStore_isset = YES;
}

- (BOOL) appStoreIsSet {
  return __appStore_isset;
}

- (void) unsetAppStore {
  __appStore_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setAppStore: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RecommendedAppsRequest"];
  if (__language_isset) {
    if (__language != nil) {
      [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __language];
      [outProtocol writeFieldEnd];
    }
  }
  if (__appStore_isset) {
    [outProtocol writeFieldBeginWithName: @"appStore" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __appStore];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__language_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'language' is not set."];
  }
  if (!__appStore_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'appStore' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RecommendedAppsRequest("];
  [ms appendString: @"language:"];
  [ms appendFormat: @"\"%@\"", __language];
  [ms appendString: @",appStore:"];
  [ms appendFormat: @"%i", __appStore];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation recommendedappsConstants
+ (void) initialize {
}
@end

@interface getRecommendedApps_args : NSObject <TBase, NSCoding> {
  RecommendedAppsRequest * __request;

  BOOL __request_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=request, setter=setRequest:) RecommendedAppsRequest * request;
#endif

- (id) init;
- (id) initWithRequest: (RecommendedAppsRequest *) request;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (RecommendedAppsRequest *) request;
- (void) setRequest: (RecommendedAppsRequest *) request;
#endif
- (BOOL) requestIsSet;

@end

@implementation getRecommendedApps_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithRequest: (RecommendedAppsRequest *) request
{
  self = [super init];
  __request = [request retain_stub];
  __request_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"request"])
  {
    __request = [[decoder decodeObjectForKey: @"request"] retain_stub];
    __request_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__request_isset)
  {
    [encoder encodeObject: __request forKey: @"request"];
  }
}

- (void) dealloc
{
  [__request release_stub];
  [super dealloc_stub];
}

- (RecommendedAppsRequest *) request {
  return [[__request retain_stub] autorelease_stub];
}

- (void) setRequest: (RecommendedAppsRequest *) request {
  [request retain_stub];
  [__request release_stub];
  __request = request;
  __request_isset = YES;
}

- (BOOL) requestIsSet {
  return __request_isset;
}

- (void) unsetRequest {
  [__request release_stub];
  __request = nil;
  __request_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          RecommendedAppsRequest *fieldValue = [[RecommendedAppsRequest alloc] init];
          [fieldValue read: inProtocol];
          [self setRequest: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getRecommendedApps_args"];
  if (__request_isset) {
    if (__request != nil) {
      [outProtocol writeFieldBeginWithName: @"request" type: TType_STRUCT fieldID: 1];
      [__request write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getRecommendedApps_args("];
  [ms appendString: @"request:"];
  [ms appendFormat: @"%@", __request];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetRecommendedApps_result : NSObject <TBase, NSCoding> {
  RecommendedAppsResponse * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) RecommendedAppsResponse * success;
#endif

- (id) init;
- (id) initWithSuccess: (RecommendedAppsResponse *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (RecommendedAppsResponse *) success;
- (void) setSuccess: (RecommendedAppsResponse *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation GetRecommendedApps_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (RecommendedAppsResponse *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (RecommendedAppsResponse *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (RecommendedAppsResponse *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          RecommendedAppsResponse *fieldValue = [[RecommendedAppsResponse alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
  [self validate];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetRecommendedApps_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetRecommendedApps_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation RecommendedAppsServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_getRecommendedApps: (RecommendedAppsRequest *) request
{
  [outProtocol writeMessageBeginWithName: @"getRecommendedApps" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getRecommendedApps_args"];
  if (request != nil)  {
    [outProtocol writeFieldBeginWithName: @"request" type: TType_STRUCT fieldID: 1];
    [request write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (RecommendedAppsResponse *) recv_getRecommendedApps
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetRecommendedApps_result * result = [[[GetRecommendedApps_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getRecommendedApps failed: unknown result"];
}

- (RecommendedAppsResponse *) getRecommendedApps: (RecommendedAppsRequest *) request
{
  [self send_getRecommendedApps : request];
  return [self recv_getRecommendedApps];
}

@end

@implementation RecommendedAppsServiceProcessor

- (id) initWithRecommendedAppsService: (id <RecommendedAppsService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_getRecommendedApps_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getRecommendedApps"];
  }
  return self;
}

- (id<RecommendedAppsService>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getRecommendedApps_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getRecommendedApps_args * args = [[getRecommendedApps_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetRecommendedApps_result * result = [[GetRecommendedApps_result alloc] init];
  [result setSuccess: [mService getRecommendedApps: [args request]]];
  [outProtocol writeMessageBeginWithName: @"getRecommendedApps"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

