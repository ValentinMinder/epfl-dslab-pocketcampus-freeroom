/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 *
 * WARNING : Feed description method has been renamed to descriptionObject as Feed.description (attribute) exists
 */

#import <Foundation/Foundation.h>

#import <TProtocol.h>
#import <TApplicationException.h>
#import <TProtocolUtil.h>
#import <TProcessor.h>

#import "common.h"

#import "news.h"

@implementation NewsItem

- (id) initWithNewsItemId: (Id) newsItemId title: (NSString *) title link: (NSString *) link feed: (NSString *) feed pubDate: (timestamp) pubDate imageUrl: (NSString *) imageUrl
{
  self = [super init];
  __newsItemId = newsItemId;
  __newsItemId_isset = YES;
  __title = [title retain];
  __title_isset = YES;
  __link = [link retain];
  __link_isset = YES;
  __feed = [feed retain];
  __feed_isset = YES;
  __pubDate = pubDate;
  __pubDate_isset = YES;
  __imageUrl = [imageUrl retain];
  __imageUrl_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"newsItemId"])
  {
    __newsItemId = [decoder decodeInt64ForKey: @"newsItemId"];
    __newsItemId_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain];
    __title_isset = YES;
  }
  if ([decoder containsValueForKey: @"link"])
  {
    __link = [[decoder decodeObjectForKey: @"link"] retain];
    __link_isset = YES;
  }
  if ([decoder containsValueForKey: @"feed"])
  {
    __feed = [[decoder decodeObjectForKey: @"feed"] retain];
    __feed_isset = YES;
  }
  if ([decoder containsValueForKey: @"pubDate"])
  {
    __pubDate = [decoder decodeInt64ForKey: @"pubDate"];
    __pubDate_isset = YES;
  }
  if ([decoder containsValueForKey: @"imageUrl"])
  {
    __imageUrl = [[decoder decodeObjectForKey: @"imageUrl"] retain];
    __imageUrl_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__newsItemId_isset)
  {
    [encoder encodeInt64: __newsItemId forKey: @"newsItemId"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
  if (__link_isset)
  {
    [encoder encodeObject: __link forKey: @"link"];
  }
  if (__feed_isset)
  {
    [encoder encodeObject: __feed forKey: @"feed"];
  }
  if (__pubDate_isset)
  {
    [encoder encodeInt64: __pubDate forKey: @"pubDate"];
  }
  if (__imageUrl_isset)
  {
    [encoder encodeObject: __imageUrl forKey: @"imageUrl"];
  }
}

- (void) dealloc
{
  [__title release];
  [__link release];
  [__feed release];
  [__imageUrl release];
  [super dealloc];
}

- (int64_t) newsItemId {
  return __newsItemId;
}

- (void) setNewsItemId: (int64_t) newsItemId {
  __newsItemId = newsItemId;
  __newsItemId_isset = YES;
}

- (BOOL) newsItemIdIsSet {
  return __newsItemId_isset;
}

- (void) unsetNewsItemId {
  __newsItemId_isset = NO;
}

- (NSString *) title {
  return [[__title retain] autorelease];
}

- (void) setTitle: (NSString *) title {
  [title retain];
  [__title release];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release];
  __title = nil;
  __title_isset = NO;
}

- (NSString *) link {
  return [[__link retain] autorelease];
}

- (void) setLink: (NSString *) link {
  [link retain];
  [__link release];
  __link = link;
  __link_isset = YES;
}

- (BOOL) linkIsSet {
  return __link_isset;
}

- (void) unsetLink {
  [__link release];
  __link = nil;
  __link_isset = NO;
}

- (NSString *) feed {
  return [[__feed retain] autorelease];
}

- (void) setFeed: (NSString *) feed {
  [feed retain];
  [__feed release];
  __feed = feed;
  __feed_isset = YES;
}

- (BOOL) feedIsSet {
  return __feed_isset;
}

- (void) unsetFeed {
  [__feed release];
  __feed = nil;
  __feed_isset = NO;
}

- (int64_t) pubDate {
  return __pubDate;
}

- (void) setPubDate: (int64_t) pubDate {
  __pubDate = pubDate;
  __pubDate_isset = YES;
}

- (BOOL) pubDateIsSet {
  return __pubDate_isset;
}

- (void) unsetPubDate {
  __pubDate_isset = NO;
}

- (NSString *) imageUrl {
  return [[__imageUrl retain] autorelease];
}

- (void) setImageUrl: (NSString *) imageUrl {
  [imageUrl retain];
  [__imageUrl release];
  __imageUrl = imageUrl;
  __imageUrl_isset = YES;
}

- (BOOL) imageUrlIsSet {
  return __imageUrl_isset;
}

- (void) unsetImageUrl {
  [__imageUrl release];
  __imageUrl = nil;
  __imageUrl_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setNewsItemId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLink: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setFeed: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setPubDate: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setImageUrl: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NewsItem"];
  if (__newsItemId_isset) {
    [outProtocol writeFieldBeginWithName: @"newsItemId" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __newsItemId];
    [outProtocol writeFieldEnd];
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  if (__link_isset) {
    if (__link != nil) {
      [outProtocol writeFieldBeginWithName: @"link" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __link];
      [outProtocol writeFieldEnd];
    }
  }
  if (__feed_isset) {
    if (__feed != nil) {
      [outProtocol writeFieldBeginWithName: @"feed" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __feed];
      [outProtocol writeFieldEnd];
    }
  }
  if (__pubDate_isset) {
    [outProtocol writeFieldBeginWithName: @"pubDate" type: TType_I64 fieldID: 5];
    [outProtocol writeI64: __pubDate];
    [outProtocol writeFieldEnd];
  }
  if (__imageUrl_isset) {
    if (__imageUrl != nil) {
      [outProtocol writeFieldBeginWithName: @"imageUrl" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __imageUrl];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NewsItem("];
  [ms appendString: @"newsItemId:"];
  [ms appendFormat: @"%qi", __newsItemId];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @",link:"];
  [ms appendFormat: @"\"%@\"", __link];
  [ms appendString: @",feed:"];
  [ms appendFormat: @"\"%@\"", __feed];
  [ms appendString: @",pubDate:"];
  [ms appendFormat: @"%qi", __pubDate];
  [ms appendString: @",imageUrl:"];
  [ms appendFormat: @"\"%@\"", __imageUrl];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Feed

- (id) initWithFeedId: (Id) feedId title: (NSString *) title link: (NSString *) link description: (NSString *) description items: (NSArray *) items
{
  self = [super init];
  __feedId = feedId;
  __feedId_isset = YES;
  __title = [title retain];
  __title_isset = YES;
  __link = [link retain];
  __link_isset = YES;
  __description = [description retain];
  __description_isset = YES;
  __items = [items retain];
  __items_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"feedId"])
  {
    __feedId = [decoder decodeInt64ForKey: @"feedId"];
    __feedId_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain];
    __title_isset = YES;
  }
  if ([decoder containsValueForKey: @"link"])
  {
    __link = [[decoder decodeObjectForKey: @"link"] retain];
    __link_isset = YES;
  }
  if ([decoder containsValueForKey: @"description"])
  {
    __description = [[decoder decodeObjectForKey: @"description"] retain];
    __description_isset = YES;
  }
  if ([decoder containsValueForKey: @"items"])
  {
    __items = [[decoder decodeObjectForKey: @"items"] retain];
    __items_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__feedId_isset)
  {
    [encoder encodeInt64: __feedId forKey: @"feedId"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
  if (__link_isset)
  {
    [encoder encodeObject: __link forKey: @"link"];
  }
  if (__description_isset)
  {
    [encoder encodeObject: __description forKey: @"description"];
  }
  if (__items_isset)
  {
    [encoder encodeObject: __items forKey: @"items"];
  }
}

- (void) dealloc
{
  [__title release];
  [__link release];
  [__description release];
  [__items release];
  [super dealloc];
}

- (int64_t) feedId {
  return __feedId;
}

- (void) setFeedId: (int64_t) feedId {
  __feedId = feedId;
  __feedId_isset = YES;
}

- (BOOL) feedIdIsSet {
  return __feedId_isset;
}

- (void) unsetFeedId {
  __feedId_isset = NO;
}

- (NSString *) title {
  return [[__title retain] autorelease];
}

- (void) setTitle: (NSString *) title {
  [title retain];
  [__title release];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release];
  __title = nil;
  __title_isset = NO;
}

- (NSString *) link {
  return [[__link retain] autorelease];
}

- (void) setLink: (NSString *) link {
  [link retain];
  [__link release];
  __link = link;
  __link_isset = YES;
}

- (BOOL) linkIsSet {
  return __link_isset;
}

- (void) unsetLink {
  [__link release];
  __link = nil;
  __link_isset = NO;
}

- (NSString *) description {
  return [[__description retain] autorelease];
}

- (void) setDescription: (NSString *) description {
  [description retain];
  [__description release];
  __description = description;
  __description_isset = YES;
}

- (BOOL) descriptionIsSet {
  return __description_isset;
}

- (void) unsetDescription {
  [__description release];
  __description = nil;
  __description_isset = NO;
}

- (NSArray *) items {
  return [[__items retain] autorelease];
}

- (void) setItems: (NSArray *) items {
  [items retain];
  [__items release];
  __items = items;
  __items_isset = YES;
}

- (BOOL) itemsIsSet {
  return __items_isset;
}

- (void) unsetItems {
  [__items release];
  __items = nil;
  __items_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setFeedId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLink: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDescription: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            NewsItem *_elem2 = [[NewsItem alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release];
          }
          [inProtocol readListEnd];
          [self setItems: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Feed"];
  if (__feedId_isset) {
    [outProtocol writeFieldBeginWithName: @"feedId" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __feedId];
    [outProtocol writeFieldEnd];
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  if (__link_isset) {
    if (__link != nil) {
      [outProtocol writeFieldBeginWithName: @"link" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __link];
      [outProtocol writeFieldEnd];
    }
  }
  if (__description_isset) {
    if (__description != nil) {
      [outProtocol writeFieldBeginWithName: @"description" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __description];
      [outProtocol writeFieldEnd];
    }
  }
  if (__items_isset) {
    if (__items != nil) {
      [outProtocol writeFieldBeginWithName: @"items" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__items count]];
        int i4;
        for (i4 = 0; i4 < [__items count]; i4++)
        {
          [[__items objectAtIndex: i4] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) descriptionObject {
  NSMutableString * ms = [NSMutableString stringWithString: @"Feed("];
  [ms appendString: @"feedId:"];
  [ms appendFormat: @"%qi", __feedId];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @",link:"];
  [ms appendFormat: @"\"%@\"", __link];
  [ms appendString: @",description:"];
  [ms appendFormat: @"\"%@\"", __description];
  [ms appendString: @",items:"];
  [ms appendFormat: @"%@", __items];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation newsConstants
+ (void) initialize {
}
@end

@interface getNewsItems_args : NSObject <NSCoding> {
  NSString * __language;

  BOOL __language_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=language, setter=setLanguage:) NSString * language;
#endif

- (id) initWithLanguage: (NSString *) language;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) language;
- (void) setLanguage: (NSString *) language;
- (BOOL) languageIsSet;

@end

@implementation getNewsItems_args

- (id) initWithLanguage: (NSString *) language
{
  self = [super init];
  __language = [language retain];
  __language_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"language"])
  {
    __language = [[decoder decodeObjectForKey: @"language"] retain];
    __language_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__language_isset)
  {
    [encoder encodeObject: __language forKey: @"language"];
  }
}

- (void) dealloc
{
  [__language release];
  [super dealloc];
}

- (NSString *) language {
  return [[__language retain] autorelease];
}

- (void) setLanguage: (NSString *) language {
  [language retain];
  [__language release];
  __language = language;
  __language_isset = YES;
}

- (BOOL) languageIsSet {
  return __language_isset;
}

- (void) unsetLanguage {
  [__language release];
  __language = nil;
  __language_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNewsItems_args"];
  if (__language_isset) {
    if (__language != nil) {
      [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __language];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNewsItems_args("];
  [ms appendString: @"language:"];
  [ms appendFormat: @"\"%@\"", __language];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetNewsItems_result : NSObject <NSCoding> {
  NSArray * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
#endif

- (id) initWithSuccess: (NSArray *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

@end

@implementation GetNewsItems_result

- (id) initWithSuccess: (NSArray *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size5;
          [inProtocol readListBeginReturningElementType: NULL size: &_size5];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size5];
          int _i6;
          for (_i6 = 0; _i6 < _size5; ++_i6)
          {
            NewsItem *_elem7 = [[NewsItem alloc] init];
            [_elem7 read: inProtocol];
            [fieldValue addObject: _elem7];
            [_elem7 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNewsItems_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i9;
        for (i9 = 0; i9 < [__success count]; i9++)
        {
          [[__success objectAtIndex: i9] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNewsItems_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface getNewsItemContent_args : NSObject <NSCoding> {
  Id __newsItemId;

  BOOL __newsItemId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=newsItemId, setter=setNewsItemId:) Id newsItemId;
#endif

- (id) initWithNewsItemId: (Id) newsItemId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (Id) newsItemId;
- (void) setNewsItemId: (Id) newsItemId;
- (BOOL) newsItemIdIsSet;

@end

@implementation getNewsItemContent_args

- (id) initWithNewsItemId: (Id) newsItemId
{
  self = [super init];
  __newsItemId = newsItemId;
  __newsItemId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"newsItemId"])
  {
    __newsItemId = [decoder decodeInt64ForKey: @"newsItemId"];
    __newsItemId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__newsItemId_isset)
  {
    [encoder encodeInt64: __newsItemId forKey: @"newsItemId"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int64_t) newsItemId {
  return __newsItemId;
}

- (void) setNewsItemId: (int64_t) newsItemId {
  __newsItemId = newsItemId;
  __newsItemId_isset = YES;
}

- (BOOL) newsItemIdIsSet {
  return __newsItemId_isset;
}

- (void) unsetNewsItemId {
  __newsItemId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setNewsItemId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNewsItemContent_args"];
  if (__newsItemId_isset) {
    [outProtocol writeFieldBeginWithName: @"newsItemId" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __newsItemId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNewsItemContent_args("];
  [ms appendString: @"newsItemId:"];
  [ms appendFormat: @"%qi", __newsItemId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetNewsItemContent_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation GetNewsItemContent_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNewsItemContent_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNewsItemContent_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface getFeedUrls_args : NSObject <NSCoding> {
  NSString * __language;

  BOOL __language_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=language, setter=setLanguage:) NSString * language;
#endif

- (id) initWithLanguage: (NSString *) language;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) language;
- (void) setLanguage: (NSString *) language;
- (BOOL) languageIsSet;

@end

@implementation getFeedUrls_args

- (id) initWithLanguage: (NSString *) language
{
  self = [super init];
  __language = [language retain];
  __language_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"language"])
  {
    __language = [[decoder decodeObjectForKey: @"language"] retain];
    __language_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__language_isset)
  {
    [encoder encodeObject: __language forKey: @"language"];
  }
}

- (void) dealloc
{
  [__language release];
  [super dealloc];
}

- (NSString *) language {
  return [[__language retain] autorelease];
}

- (void) setLanguage: (NSString *) language {
  [language retain];
  [__language release];
  __language = language;
  __language_isset = YES;
}

- (BOOL) languageIsSet {
  return __language_isset;
}

- (void) unsetLanguage {
  [__language release];
  __language = nil;
  __language_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getFeedUrls_args"];
  if (__language_isset) {
    if (__language != nil) {
      [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __language];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getFeedUrls_args("];
  [ms appendString: @"language:"];
  [ms appendFormat: @"\"%@\"", __language];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetFeedUrls_result : NSObject <NSCoding> {
  NSDictionary * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSDictionary * success;
#endif

- (id) initWithSuccess: (NSDictionary *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSDictionary *) success;
- (void) setSuccess: (NSDictionary *) success;
- (BOOL) successIsSet;

@end

@implementation GetFeedUrls_result

- (id) initWithSuccess: (NSDictionary *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSDictionary *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSDictionary *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_MAP) {
          int _size10;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size10];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size10];
          int _i11;
          for (_i11 = 0; _i11 < _size10; ++_i11)
          {
            NSString * _key12 = [inProtocol readString];
            NSString * _val13 = [inProtocol readString];
            [fieldValue setObject: _val13 forKey: _key12];
          }
          [inProtocol readMapEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetFeedUrls_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_MAP fieldID: 0];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_STRING size: [__success count]];
        NSEnumerator * _iter14 = [__success keyEnumerator];
        id key15;
        while ((key15 = [_iter14 nextObject]))
        {
          [outProtocol writeString: key15];
          [outProtocol writeString: [__success objectForKey: key15]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetFeedUrls_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface getFeeds_args : NSObject <NSCoding> {
  NSString * __language;

  BOOL __language_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=language, setter=setLanguage:) NSString * language;
#endif

- (id) initWithLanguage: (NSString *) language;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) language;
- (void) setLanguage: (NSString *) language;
- (BOOL) languageIsSet;

@end

@implementation getFeeds_args

- (id) initWithLanguage: (NSString *) language
{
  self = [super init];
  __language = [language retain];
  __language_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"language"])
  {
    __language = [[decoder decodeObjectForKey: @"language"] retain];
    __language_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__language_isset)
  {
    [encoder encodeObject: __language forKey: @"language"];
  }
}

- (void) dealloc
{
  [__language release];
  [super dealloc];
}

- (NSString *) language {
  return [[__language retain] autorelease];
}

- (void) setLanguage: (NSString *) language {
  [language retain];
  [__language release];
  __language = language;
  __language_isset = YES;
}

- (BOOL) languageIsSet {
  return __language_isset;
}

- (void) unsetLanguage {
  [__language release];
  __language = nil;
  __language_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getFeeds_args"];
  if (__language_isset) {
    if (__language != nil) {
      [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __language];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getFeeds_args("];
  [ms appendString: @"language:"];
  [ms appendFormat: @"\"%@\"", __language];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetFeeds_result : NSObject <NSCoding> {
  NSArray * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
#endif

- (id) initWithSuccess: (NSArray *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

@end

@implementation GetFeeds_result

- (id) initWithSuccess: (NSArray *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size16;
          [inProtocol readListBeginReturningElementType: NULL size: &_size16];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size16];
          int _i17;
          for (_i17 = 0; _i17 < _size16; ++_i17)
          {
            Feed *_elem18 = [[Feed alloc] init];
            [_elem18 read: inProtocol];
            [fieldValue addObject: _elem18];
            [_elem18 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetFeeds_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i20;
        for (i20 = 0; i20 < [__success count]; i20++)
        {
          [[__success objectAtIndex: i20] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetFeeds_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation NewsServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  [super init];
  inProtocol = [anInProtocol retain];
  outProtocol = [anOutProtocol retain];
  return self;
}

- (void) dealloc
{
  [inProtocol release];
  [outProtocol release];
  [super dealloc];
}

- (void) send_getNewsItems: (NSString *) language
{
  [outProtocol writeMessageBeginWithName: @"getNewsItems" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNewsItems_args"];
  if (language != nil)  {
    [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
    [outProtocol writeString: language];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getNewsItems
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetNewsItems_result * result = [[[GetNewsItems_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNewsItems failed: unknown result"];
}

- (NSArray *) getNewsItems: (NSString *) language
{
  [self send_getNewsItems: language];
  return [self recv_getNewsItems];
}

- (void) send_getNewsItemContent: (Id) newsItemId
{
  [outProtocol writeMessageBeginWithName: @"getNewsItemContent" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNewsItemContent_args"];
  [outProtocol writeFieldBeginWithName: @"newsItemId" type: TType_I64 fieldID: 1];
  [outProtocol writeI64: newsItemId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNewsItemContent
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetNewsItemContent_result * result = [[[GetNewsItemContent_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNewsItemContent failed: unknown result"];
}

- (NSString *) getNewsItemContent: (Id) newsItemId
{
  [self send_getNewsItemContent: newsItemId];
  return [self recv_getNewsItemContent];
}

- (void) send_getFeedUrls: (NSString *) language
{
  [outProtocol writeMessageBeginWithName: @"getFeedUrls" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getFeedUrls_args"];
  if (language != nil)  {
    [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
    [outProtocol writeString: language];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSDictionary *) recv_getFeedUrls
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetFeedUrls_result * result = [[[GetFeedUrls_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getFeedUrls failed: unknown result"];
}

- (NSDictionary *) getFeedUrls: (NSString *) language
{
  [self send_getFeedUrls: language];
  return [self recv_getFeedUrls];
}

- (void) send_getFeeds: (NSString *) language
{
  [outProtocol writeMessageBeginWithName: @"getFeeds" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getFeeds_args"];
  if (language != nil)  {
    [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 1];
    [outProtocol writeString: language];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getFeeds
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetFeeds_result * result = [[[GetFeeds_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getFeeds failed: unknown result"];
}

- (NSArray *) getFeeds: (NSString *) language
{
  [self send_getFeeds: language];
  return [self recv_getFeeds];
}

@end

@implementation NewsServiceProcessor

- (id) initWithNewsService: (id <NewsService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain];
  mMethodMap = [[NSMutableDictionary dictionary] retain];
  {
    SEL s = @selector(process_getNewsItems_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNewsItems"];
  }
  {
    SEL s = @selector(process_getNewsItemContent_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNewsItemContent"];
  }
  {
    SEL s = @selector(process_getFeedUrls_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getFeedUrls"];
  }
  {
    SEL s = @selector(process_getFeeds_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getFeeds"];
  }
  return self;
}

- (id<NewsService>) service
{
  return [[mService retain] autorelease];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getNewsItems_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getNewsItems_args * args = [[getNewsItems_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetNewsItems_result * result = [[GetNewsItems_result alloc] init];
  [result setSuccess: [mService getNewsItems: [args language]]];
  [outProtocol writeMessageBeginWithName: @"getNewsItems"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNewsItemContent_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getNewsItemContent_args * args = [[getNewsItemContent_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetNewsItemContent_result * result = [[GetNewsItemContent_result alloc] init];
  [result setSuccess: [mService getNewsItemContent: [args newsItemId]]];
  [outProtocol writeMessageBeginWithName: @"getNewsItemContent"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getFeedUrls_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getFeedUrls_args * args = [[getFeedUrls_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetFeedUrls_result * result = [[GetFeedUrls_result alloc] init];
  [result setSuccess: [mService getFeedUrls: [args language]]];
  [outProtocol writeMessageBeginWithName: @"getFeedUrls"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getFeeds_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getFeeds_args * args = [[getFeeds_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetFeeds_result * result = [[GetFeeds_result alloc] init];
  [result setSuccess: [mService getFeeds: [args language]]];
  [outProtocol writeMessageBeginWithName: @"getFeeds"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) dealloc
{
  [mService release];
  [mMethodMap release];
  [super dealloc];
}

@end

