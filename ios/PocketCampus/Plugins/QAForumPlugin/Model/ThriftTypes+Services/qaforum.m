/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#import <Foundation/Foundation.h>

#import <TProtocol.h>
#import <TApplicationException.h>
#import <TProtocolUtil.h>
#import <TProcessor.h>


#import "qaforum.h"


@implementation qaforumConstants
+ (void) initialize {
}
@end

@implementation QATequilaToken

- (id) initWithITequilaKey: (NSString *) iTequilaKey loginCookie: (NSString *) loginCookie
{
  self = [super init];
  __iTequilaKey = [iTequilaKey retain];
  __iTequilaKey_isset = YES;
  __loginCookie = [loginCookie retain];
  __loginCookie_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"iTequilaKey"])
  {
    __iTequilaKey = [[decoder decodeObjectForKey: @"iTequilaKey"] retain];
    __iTequilaKey_isset = YES;
  }
  if ([decoder containsValueForKey: @"loginCookie"])
  {
    __loginCookie = [[decoder decodeObjectForKey: @"loginCookie"] retain];
    __loginCookie_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__iTequilaKey_isset)
  {
    [encoder encodeObject: __iTequilaKey forKey: @"iTequilaKey"];
  }
  if (__loginCookie_isset)
  {
    [encoder encodeObject: __loginCookie forKey: @"loginCookie"];
  }
}

- (void) dealloc
{
  [__iTequilaKey release];
  [__loginCookie release];
  [super dealloc];
}

- (NSString *) iTequilaKey {
  return [[__iTequilaKey retain] autorelease];
}

- (void) setITequilaKey: (NSString *) iTequilaKey {
  [iTequilaKey retain];
  [__iTequilaKey release];
  __iTequilaKey = iTequilaKey;
  __iTequilaKey_isset = YES;
}

- (BOOL) iTequilaKeyIsSet {
  return __iTequilaKey_isset;
}

- (void) unsetITequilaKey {
  [__iTequilaKey release];
  __iTequilaKey = nil;
  __iTequilaKey_isset = NO;
}

- (NSString *) loginCookie {
  return [[__loginCookie retain] autorelease];
}

- (void) setLoginCookie: (NSString *) loginCookie {
  [loginCookie retain];
  [__loginCookie release];
  __loginCookie = loginCookie;
  __loginCookie_isset = YES;
}

- (BOOL) loginCookieIsSet {
  return __loginCookie_isset;
}

- (void) unsetLoginCookie {
  [__loginCookie release];
  __loginCookie = nil;
  __loginCookie_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setITequilaKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLoginCookie: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"QATequilaToken"];
  if (__iTequilaKey_isset) {
    if (__iTequilaKey != nil) {
      [outProtocol writeFieldBeginWithName: @"iTequilaKey" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __iTequilaKey];
      [outProtocol writeFieldEnd];
    }
  }
  if (__loginCookie_isset) {
    if (__loginCookie != nil) {
      [outProtocol writeFieldBeginWithName: @"loginCookie" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __loginCookie];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"QATequilaToken("];
  [ms appendString: @"iTequilaKey:"];
  [ms appendFormat: @"\"%@\"", __iTequilaKey];
  [ms appendString: @",loginCookie:"];
  [ms appendFormat: @"\"%@\"", __loginCookie];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_ask

- (id) initWithSessionid: (NSString *) sessionid content: (NSString *) content topic: (int32_t) topic tags: (NSString *) tags expirytime: (int32_t) expirytime quesid: (int32_t) quesid
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __content = [content retain];
  __content_isset = YES;
  __topic = topic;
  __topic_isset = YES;
  __tags = [tags retain];
  __tags_isset = YES;
  __expirytime = expirytime;
  __expirytime_isset = YES;
  __quesid = quesid;
  __quesid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"content"])
  {
    __content = [[decoder decodeObjectForKey: @"content"] retain];
    __content_isset = YES;
  }
  if ([decoder containsValueForKey: @"topic"])
  {
    __topic = [decoder decodeInt32ForKey: @"topic"];
    __topic_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"expirytime"])
  {
    __expirytime = [decoder decodeInt32ForKey: @"expirytime"];
    __expirytime_isset = YES;
  }
  if ([decoder containsValueForKey: @"quesid"])
  {
    __quesid = [decoder decodeInt32ForKey: @"quesid"];
    __quesid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__content_isset)
  {
    [encoder encodeObject: __content forKey: @"content"];
  }
  if (__topic_isset)
  {
    [encoder encodeInt32: __topic forKey: @"topic"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__expirytime_isset)
  {
    [encoder encodeInt32: __expirytime forKey: @"expirytime"];
  }
  if (__quesid_isset)
  {
    [encoder encodeInt32: __quesid forKey: @"quesid"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__content release];
  [__tags release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (NSString *) content {
  return [[__content retain] autorelease];
}

- (void) setContent: (NSString *) content {
  [content retain];
  [__content release];
  __content = content;
  __content_isset = YES;
}

- (BOOL) contentIsSet {
  return __content_isset;
}

- (void) unsetContent {
  [__content release];
  __content = nil;
  __content_isset = NO;
}

- (int32_t) topic {
  return __topic;
}

- (void) setTopic: (int32_t) topic {
  __topic = topic;
  __topic_isset = YES;
}

- (BOOL) topicIsSet {
  return __topic_isset;
}

- (void) unsetTopic {
  __topic_isset = NO;
}

- (NSString *) tags {
  return [[__tags retain] autorelease];
}

- (void) setTags: (NSString *) tags {
  [tags retain];
  [__tags release];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release];
  __tags = nil;
  __tags_isset = NO;
}

- (int32_t) expirytime {
  return __expirytime;
}

- (void) setExpirytime: (int32_t) expirytime {
  __expirytime = expirytime;
  __expirytime_isset = YES;
}

- (BOOL) expirytimeIsSet {
  return __expirytime_isset;
}

- (void) unsetExpirytime {
  __expirytime_isset = NO;
}

- (int32_t) quesid {
  return __quesid;
}

- (void) setQuesid: (int32_t) quesid {
  __quesid = quesid;
  __quesid_isset = YES;
}

- (BOOL) quesidIsSet {
  return __quesid_isset;
}

- (void) unsetQuesid {
  __quesid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setContent: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTopic: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setExpirytime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setQuesid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_ask"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__content_isset) {
    if (__content != nil) {
      [outProtocol writeFieldBeginWithName: @"content" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __content];
      [outProtocol writeFieldEnd];
    }
  }
  if (__topic_isset) {
    [outProtocol writeFieldBeginWithName: @"topic" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __topic];
    [outProtocol writeFieldEnd];
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __tags];
      [outProtocol writeFieldEnd];
    }
  }
  if (__expirytime_isset) {
    [outProtocol writeFieldBeginWithName: @"expirytime" type: TType_I32 fieldID: 5];
    [outProtocol writeI32: __expirytime];
    [outProtocol writeFieldEnd];
  }
  if (__quesid_isset) {
    [outProtocol writeFieldBeginWithName: @"quesid" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __quesid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_ask("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",content:"];
  [ms appendFormat: @"\"%@\"", __content];
  [ms appendString: @",topic:"];
  [ms appendFormat: @"%i", __topic];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"\"%@\"", __tags];
  [ms appendString: @",expirytime:"];
  [ms appendFormat: @"%i", __expirytime];
  [ms appendString: @",quesid:"];
  [ms appendFormat: @"%i", __quesid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_accept

- (id) initWithNotificationid: (int32_t) notificationid accept: (int32_t) accept
{
  self = [super init];
  __notificationid = notificationid;
  __notificationid_isset = YES;
  __accept = accept;
  __accept_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"notificationid"])
  {
    __notificationid = [decoder decodeInt32ForKey: @"notificationid"];
    __notificationid_isset = YES;
  }
  if ([decoder containsValueForKey: @"accept"])
  {
    __accept = [decoder decodeInt32ForKey: @"accept"];
    __accept_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__notificationid_isset)
  {
    [encoder encodeInt32: __notificationid forKey: @"notificationid"];
  }
  if (__accept_isset)
  {
    [encoder encodeInt32: __accept forKey: @"accept"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) notificationid {
  return __notificationid;
}

- (void) setNotificationid: (int32_t) notificationid {
  __notificationid = notificationid;
  __notificationid_isset = YES;
}

- (BOOL) notificationidIsSet {
  return __notificationid_isset;
}

- (void) unsetNotificationid {
  __notificationid_isset = NO;
}

- (int32_t) accept {
  return __accept;
}

- (void) setAccept: (int32_t) accept {
  __accept = accept;
  __accept_isset = YES;
}

- (BOOL) acceptIsSet {
  return __accept_isset;
}

- (void) unsetAccept {
  __accept_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setNotificationid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAccept: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_accept"];
  if (__notificationid_isset) {
    [outProtocol writeFieldBeginWithName: @"notificationid" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __notificationid];
    [outProtocol writeFieldEnd];
  }
  if (__accept_isset) {
    [outProtocol writeFieldBeginWithName: @"accept" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __accept];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_accept("];
  [ms appendString: @"notificationid:"];
  [ms appendFormat: @"%i", __notificationid];
  [ms appendString: @",accept:"];
  [ms appendFormat: @"%i", __accept];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_request

- (id) initWithSessionid: (NSString *) sessionid topics: (NSString *) topics tags: (NSString *) tags
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __topics = [topics retain];
  __topics_isset = YES;
  __tags = [tags retain];
  __tags_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"topics"])
  {
    __topics = [[decoder decodeObjectForKey: @"topics"] retain];
    __topics_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain];
    __tags_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__topics_isset)
  {
    [encoder encodeObject: __topics forKey: @"topics"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__topics release];
  [__tags release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (NSString *) topics {
  return [[__topics retain] autorelease];
}

- (void) setTopics: (NSString *) topics {
  [topics retain];
  [__topics release];
  __topics = topics;
  __topics_isset = YES;
}

- (BOOL) topicsIsSet {
  return __topics_isset;
}

- (void) unsetTopics {
  [__topics release];
  __topics = nil;
  __topics_isset = NO;
}

- (NSString *) tags {
  return [[__tags retain] autorelease];
}

- (void) setTags: (NSString *) tags {
  [tags retain];
  [__tags release];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release];
  __tags = nil;
  __tags_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTopics: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_request"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__topics_isset) {
    if (__topics != nil) {
      [outProtocol writeFieldBeginWithName: @"topics" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __topics];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __tags];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_request("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",topics:"];
  [ms appendFormat: @"\"%@\"", __topics];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"\"%@\"", __tags];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_answer

- (id) initWithSessionid: (NSString *) sessionid forwardid: (int32_t) forwardid answer: (NSString *) answer typeid: (int32_t) typeid
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __forwardid = forwardid;
  __forwardid_isset = YES;
  __answer = [answer retain];
  __answer_isset = YES;
  __typeid = typeid;
  __typeid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  if ([decoder containsValueForKey: @"answer"])
  {
    __answer = [[decoder decodeObjectForKey: @"answer"] retain];
    __answer_isset = YES;
  }
  if ([decoder containsValueForKey: @"typeid"])
  {
    __typeid = [decoder decodeInt32ForKey: @"typeid"];
    __typeid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
  if (__answer_isset)
  {
    [encoder encodeObject: __answer forKey: @"answer"];
  }
  if (__typeid_isset)
  {
    [encoder encodeInt32: __typeid forKey: @"typeid"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__answer release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (NSString *) answer {
  return [[__answer retain] autorelease];
}

- (void) setAnswer: (NSString *) answer {
  [answer retain];
  [__answer release];
  __answer = answer;
  __answer_isset = YES;
}

- (BOOL) answerIsSet {
  return __answer_isset;
}

- (void) unsetAnswer {
  [__answer release];
  __answer = nil;
  __answer_isset = NO;
}

- (int32_t) typeid {
  return __typeid;
}

- (void) setTypeid: (int32_t) typeid {
  __typeid = typeid;
  __typeid_isset = YES;
}

- (BOOL) typeidIsSet {
  return __typeid_isset;
}

- (void) unsetTypeid {
  __typeid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAnswer: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTypeid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_answer"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  if (__answer_isset) {
    if (__answer != nil) {
      [outProtocol writeFieldBeginWithName: @"answer" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __answer];
      [outProtocol writeFieldEnd];
    }
  }
  if (__typeid_isset) {
    [outProtocol writeFieldBeginWithName: @"typeid" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __typeid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_answer("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @",answer:"];
  [ms appendFormat: @"\"%@\"", __answer];
  [ms appendString: @",typeid:"];
  [ms appendFormat: @"%i", __typeid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_report

- (id) initWithSessionid: (NSString *) sessionid forwardid: (int32_t) forwardid type: (int32_t) type comment: (NSString *) comment
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __forwardid = forwardid;
  __forwardid_isset = YES;
  __type = type;
  __type_isset = YES;
  __comment = [comment retain];
  __comment_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  if ([decoder containsValueForKey: @"type"])
  {
    __type = [decoder decodeInt32ForKey: @"type"];
    __type_isset = YES;
  }
  if ([decoder containsValueForKey: @"comment"])
  {
    __comment = [[decoder decodeObjectForKey: @"comment"] retain];
    __comment_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
  if (__type_isset)
  {
    [encoder encodeInt32: __type forKey: @"type"];
  }
  if (__comment_isset)
  {
    [encoder encodeObject: __comment forKey: @"comment"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__comment release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (int32_t) type {
  return __type;
}

- (void) setType: (int32_t) type {
  __type = type;
  __type_isset = YES;
}

- (BOOL) typeIsSet {
  return __type_isset;
}

- (void) unsetType {
  __type_isset = NO;
}

- (NSString *) comment {
  return [[__comment retain] autorelease];
}

- (void) setComment: (NSString *) comment {
  [comment retain];
  [__comment release];
  __comment = comment;
  __comment_isset = YES;
}

- (BOOL) commentIsSet {
  return __comment_isset;
}

- (void) unsetComment {
  [__comment release];
  __comment = nil;
  __comment_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setType: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setComment: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_report"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  if (__type_isset) {
    [outProtocol writeFieldBeginWithName: @"type" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __type];
    [outProtocol writeFieldEnd];
  }
  if (__comment_isset) {
    if (__comment != nil) {
      [outProtocol writeFieldBeginWithName: @"comment" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __comment];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_report("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @",type:"];
  [ms appendFormat: @"%i", __type];
  [ms appendString: @",comment:"];
  [ms appendFormat: @"\"%@\"", __comment];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_feedback

- (id) initWithSessionid: (NSString *) sessionid forwardid: (int32_t) forwardid feedback: (NSString *) feedback rate: (double) rate
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __forwardid = forwardid;
  __forwardid_isset = YES;
  __feedback = [feedback retain];
  __feedback_isset = YES;
  __rate = rate;
  __rate_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  if ([decoder containsValueForKey: @"feedback"])
  {
    __feedback = [[decoder decodeObjectForKey: @"feedback"] retain];
    __feedback_isset = YES;
  }
  if ([decoder containsValueForKey: @"rate"])
  {
    __rate = [decoder decodeDoubleForKey: @"rate"];
    __rate_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
  if (__feedback_isset)
  {
    [encoder encodeObject: __feedback forKey: @"feedback"];
  }
  if (__rate_isset)
  {
    [encoder encodeDouble: __rate forKey: @"rate"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__feedback release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (NSString *) feedback {
  return [[__feedback retain] autorelease];
}

- (void) setFeedback: (NSString *) feedback {
  [feedback retain];
  [__feedback release];
  __feedback = feedback;
  __feedback_isset = YES;
}

- (BOOL) feedbackIsSet {
  return __feedback_isset;
}

- (void) unsetFeedback {
  [__feedback release];
  __feedback = nil;
  __feedback_isset = NO;
}

- (double) rate {
  return __rate;
}

- (void) setRate: (double) rate {
  __rate = rate;
  __rate_isset = YES;
}

- (BOOL) rateIsSet {
  return __rate_isset;
}

- (void) unsetRate {
  __rate_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setFeedback: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_DOUBLE) {
          double fieldValue = [inProtocol readDouble];
          [self setRate: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_feedback"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  if (__feedback_isset) {
    if (__feedback != nil) {
      [outProtocol writeFieldBeginWithName: @"feedback" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __feedback];
      [outProtocol writeFieldEnd];
    }
  }
  if (__rate_isset) {
    [outProtocol writeFieldBeginWithName: @"rate" type: TType_DOUBLE fieldID: 4];
    [outProtocol writeDouble: __rate];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_feedback("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @",feedback:"];
  [ms appendFormat: @"\"%@\"", __feedback];
  [ms appendString: @",rate:"];
  [ms appendFormat: @"%f", __rate];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_questionlist

- (id) initWithForwardid: (int32_t) forwardid topic: (int32_t) topic tags: (NSString *) tags askername: (NSString *) askername time: (NSString *) time content: (NSString *) content sessionid: (NSString *) sessionid
{
  self = [super init];
  __forwardid = forwardid;
  __forwardid_isset = YES;
  __topic = topic;
  __topic_isset = YES;
  __tags = [tags retain];
  __tags_isset = YES;
  __askername = [askername retain];
  __askername_isset = YES;
  __time = [time retain];
  __time_isset = YES;
  __content = [content retain];
  __content_isset = YES;
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  if ([decoder containsValueForKey: @"topic"])
  {
    __topic = [decoder decodeInt32ForKey: @"topic"];
    __topic_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"askername"])
  {
    __askername = [[decoder decodeObjectForKey: @"askername"] retain];
    __askername_isset = YES;
  }
  if ([decoder containsValueForKey: @"time"])
  {
    __time = [[decoder decodeObjectForKey: @"time"] retain];
    __time_isset = YES;
  }
  if ([decoder containsValueForKey: @"content"])
  {
    __content = [[decoder decodeObjectForKey: @"content"] retain];
    __content_isset = YES;
  }
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
  if (__topic_isset)
  {
    [encoder encodeInt32: __topic forKey: @"topic"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__askername_isset)
  {
    [encoder encodeObject: __askername forKey: @"askername"];
  }
  if (__time_isset)
  {
    [encoder encodeObject: __time forKey: @"time"];
  }
  if (__content_isset)
  {
    [encoder encodeObject: __content forKey: @"content"];
  }
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
}

- (void) dealloc
{
  [__tags release];
  [__askername release];
  [__time release];
  [__content release];
  [__sessionid release];
  [super dealloc];
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (int32_t) topic {
  return __topic;
}

- (void) setTopic: (int32_t) topic {
  __topic = topic;
  __topic_isset = YES;
}

- (BOOL) topicIsSet {
  return __topic_isset;
}

- (void) unsetTopic {
  __topic_isset = NO;
}

- (NSString *) tags {
  return [[__tags retain] autorelease];
}

- (void) setTags: (NSString *) tags {
  [tags retain];
  [__tags release];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release];
  __tags = nil;
  __tags_isset = NO;
}

- (NSString *) askername {
  return [[__askername retain] autorelease];
}

- (void) setAskername: (NSString *) askername {
  [askername retain];
  [__askername release];
  __askername = askername;
  __askername_isset = YES;
}

- (BOOL) askernameIsSet {
  return __askername_isset;
}

- (void) unsetAskername {
  [__askername release];
  __askername = nil;
  __askername_isset = NO;
}

- (NSString *) time {
  return [[__time retain] autorelease];
}

- (void) setTime: (NSString *) time {
  [time retain];
  [__time release];
  __time = time;
  __time_isset = YES;
}

- (BOOL) timeIsSet {
  return __time_isset;
}

- (void) unsetTime {
  [__time release];
  __time = nil;
  __time_isset = NO;
}

- (NSString *) content {
  return [[__content retain] autorelease];
}

- (void) setContent: (NSString *) content {
  [content retain];
  [__content release];
  __content = content;
  __content_isset = YES;
}

- (BOOL) contentIsSet {
  return __content_isset;
}

- (void) unsetContent {
  [__content release];
  __content = nil;
  __content_isset = NO;
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTopic: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAskername: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setContent: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_questionlist"];
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  if (__topic_isset) {
    [outProtocol writeFieldBeginWithName: @"topic" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __topic];
    [outProtocol writeFieldEnd];
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __tags];
      [outProtocol writeFieldEnd];
    }
  }
  if (__askername_isset) {
    if (__askername != nil) {
      [outProtocol writeFieldBeginWithName: @"askername" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __askername];
      [outProtocol writeFieldEnd];
    }
  }
  if (__time_isset) {
    if (__time != nil) {
      [outProtocol writeFieldBeginWithName: @"time" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __time];
      [outProtocol writeFieldEnd];
    }
  }
  if (__content_isset) {
    if (__content != nil) {
      [outProtocol writeFieldBeginWithName: @"content" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __content];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 7];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_questionlist("];
  [ms appendString: @"forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @",topic:"];
  [ms appendFormat: @"%i", __topic];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"\"%@\"", __tags];
  [ms appendString: @",askername:"];
  [ms appendFormat: @"\"%@\"", __askername];
  [ms appendString: @",time:"];
  [ms appendFormat: @"\"%@\"", __time];
  [ms appendString: @",content:"];
  [ms appendFormat: @"\"%@\"", __content];
  [ms appendString: @",sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_forwardQuestions

- (id) initWithNumber: (int32_t) number questionlist: (NSArray *) questionlist
{
  self = [super init];
  __number = number;
  __number_isset = YES;
  __questionlist = [questionlist retain];
  __questionlist_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"number"])
  {
    __number = [decoder decodeInt32ForKey: @"number"];
    __number_isset = YES;
  }
  if ([decoder containsValueForKey: @"questionlist"])
  {
    __questionlist = [[decoder decodeObjectForKey: @"questionlist"] retain];
    __questionlist_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__number_isset)
  {
    [encoder encodeInt32: __number forKey: @"number"];
  }
  if (__questionlist_isset)
  {
    [encoder encodeObject: __questionlist forKey: @"questionlist"];
  }
}

- (void) dealloc
{
  [__questionlist release];
  [super dealloc];
}

- (int32_t) number {
  return __number;
}

- (void) setNumber: (int32_t) number {
  __number = number;
  __number_isset = YES;
}

- (BOOL) numberIsSet {
  return __number_isset;
}

- (void) unsetNumber {
  __number_isset = NO;
}

- (NSArray *) questionlist {
  return [[__questionlist retain] autorelease];
}

- (void) setQuestionlist: (NSArray *) questionlist {
  [questionlist retain];
  [__questionlist release];
  __questionlist = questionlist;
  __questionlist_isset = YES;
}

- (BOOL) questionlistIsSet {
  return __questionlist_isset;
}

- (void) unsetQuestionlist {
  [__questionlist release];
  __questionlist = nil;
  __questionlist_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setNumber: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            s_questionlist *_elem2 = [[s_questionlist alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release];
          }
          [inProtocol readListEnd];
          [self setQuestionlist: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_forwardQuestions"];
  if (__number_isset) {
    [outProtocol writeFieldBeginWithName: @"number" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __number];
    [outProtocol writeFieldEnd];
  }
  if (__questionlist_isset) {
    if (__questionlist != nil) {
      [outProtocol writeFieldBeginWithName: @"questionlist" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__questionlist count]];
        int i4;
        for (i4 = 0; i4 < [__questionlist count]; i4++)
        {
          [[__questionlist objectAtIndex: i4] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_forwardQuestions("];
  [ms appendString: @"number:"];
  [ms appendFormat: @"%i", __number];
  [ms appendString: @",questionlist:"];
  [ms appendFormat: @"%@", __questionlist];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_session

- (id) initWithSessionid: (NSString *) sessionid accept: (int32_t) accept resttime: (int32_t) resttime language: (NSString *) language topic: (NSString *) topic asktopic: (int32_t) asktopic askexpiry: (int32_t) askexpiry intro: (int32_t) intro
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  __accept = accept;
  __accept_isset = YES;
  __resttime = resttime;
  __resttime_isset = YES;
  __language = [language retain];
  __language_isset = YES;
  __topic = [topic retain];
  __topic_isset = YES;
  __asktopic = asktopic;
  __asktopic_isset = YES;
  __askexpiry = askexpiry;
  __askexpiry_isset = YES;
  __intro = intro;
  __intro_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  if ([decoder containsValueForKey: @"accept"])
  {
    __accept = [decoder decodeInt32ForKey: @"accept"];
    __accept_isset = YES;
  }
  if ([decoder containsValueForKey: @"resttime"])
  {
    __resttime = [decoder decodeInt32ForKey: @"resttime"];
    __resttime_isset = YES;
  }
  if ([decoder containsValueForKey: @"language"])
  {
    __language = [[decoder decodeObjectForKey: @"language"] retain];
    __language_isset = YES;
  }
  if ([decoder containsValueForKey: @"topic"])
  {
    __topic = [[decoder decodeObjectForKey: @"topic"] retain];
    __topic_isset = YES;
  }
  if ([decoder containsValueForKey: @"asktopic"])
  {
    __asktopic = [decoder decodeInt32ForKey: @"asktopic"];
    __asktopic_isset = YES;
  }
  if ([decoder containsValueForKey: @"askexpiry"])
  {
    __askexpiry = [decoder decodeInt32ForKey: @"askexpiry"];
    __askexpiry_isset = YES;
  }
  if ([decoder containsValueForKey: @"intro"])
  {
    __intro = [decoder decodeInt32ForKey: @"intro"];
    __intro_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
  if (__accept_isset)
  {
    [encoder encodeInt32: __accept forKey: @"accept"];
  }
  if (__resttime_isset)
  {
    [encoder encodeInt32: __resttime forKey: @"resttime"];
  }
  if (__language_isset)
  {
    [encoder encodeObject: __language forKey: @"language"];
  }
  if (__topic_isset)
  {
    [encoder encodeObject: __topic forKey: @"topic"];
  }
  if (__asktopic_isset)
  {
    [encoder encodeInt32: __asktopic forKey: @"asktopic"];
  }
  if (__askexpiry_isset)
  {
    [encoder encodeInt32: __askexpiry forKey: @"askexpiry"];
  }
  if (__intro_isset)
  {
    [encoder encodeInt32: __intro forKey: @"intro"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [__language release];
  [__topic release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (int32_t) accept {
  return __accept;
}

- (void) setAccept: (int32_t) accept {
  __accept = accept;
  __accept_isset = YES;
}

- (BOOL) acceptIsSet {
  return __accept_isset;
}

- (void) unsetAccept {
  __accept_isset = NO;
}

- (int32_t) resttime {
  return __resttime;
}

- (void) setResttime: (int32_t) resttime {
  __resttime = resttime;
  __resttime_isset = YES;
}

- (BOOL) resttimeIsSet {
  return __resttime_isset;
}

- (void) unsetResttime {
  __resttime_isset = NO;
}

- (NSString *) language {
  return [[__language retain] autorelease];
}

- (void) setLanguage: (NSString *) language {
  [language retain];
  [__language release];
  __language = language;
  __language_isset = YES;
}

- (BOOL) languageIsSet {
  return __language_isset;
}

- (void) unsetLanguage {
  [__language release];
  __language = nil;
  __language_isset = NO;
}

- (NSString *) topic {
  return [[__topic retain] autorelease];
}

- (void) setTopic: (NSString *) topic {
  [topic retain];
  [__topic release];
  __topic = topic;
  __topic_isset = YES;
}

- (BOOL) topicIsSet {
  return __topic_isset;
}

- (void) unsetTopic {
  [__topic release];
  __topic = nil;
  __topic_isset = NO;
}

- (int32_t) asktopic {
  return __asktopic;
}

- (void) setAsktopic: (int32_t) asktopic {
  __asktopic = asktopic;
  __asktopic_isset = YES;
}

- (BOOL) asktopicIsSet {
  return __asktopic_isset;
}

- (void) unsetAsktopic {
  __asktopic_isset = NO;
}

- (int32_t) askexpiry {
  return __askexpiry;
}

- (void) setAskexpiry: (int32_t) askexpiry {
  __askexpiry = askexpiry;
  __askexpiry_isset = YES;
}

- (BOOL) askexpiryIsSet {
  return __askexpiry_isset;
}

- (void) unsetAskexpiry {
  __askexpiry_isset = NO;
}

- (int32_t) intro {
  return __intro;
}

- (void) setIntro: (int32_t) intro {
  __intro = intro;
  __intro_isset = YES;
}

- (BOOL) introIsSet {
  return __intro_isset;
}

- (void) unsetIntro {
  __intro_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAccept: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setResttime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTopic: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAsktopic: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAskexpiry: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setIntro: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_session"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__accept_isset) {
    [outProtocol writeFieldBeginWithName: @"accept" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __accept];
    [outProtocol writeFieldEnd];
  }
  if (__resttime_isset) {
    [outProtocol writeFieldBeginWithName: @"resttime" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __resttime];
    [outProtocol writeFieldEnd];
  }
  if (__language_isset) {
    if (__language != nil) {
      [outProtocol writeFieldBeginWithName: @"language" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __language];
      [outProtocol writeFieldEnd];
    }
  }
  if (__topic_isset) {
    if (__topic != nil) {
      [outProtocol writeFieldBeginWithName: @"topic" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __topic];
      [outProtocol writeFieldEnd];
    }
  }
  if (__asktopic_isset) {
    [outProtocol writeFieldBeginWithName: @"asktopic" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __asktopic];
    [outProtocol writeFieldEnd];
  }
  if (__askexpiry_isset) {
    [outProtocol writeFieldBeginWithName: @"askexpiry" type: TType_I32 fieldID: 7];
    [outProtocol writeI32: __askexpiry];
    [outProtocol writeFieldEnd];
  }
  if (__intro_isset) {
    [outProtocol writeFieldBeginWithName: @"intro" type: TType_I32 fieldID: 8];
    [outProtocol writeI32: __intro];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_session("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @",accept:"];
  [ms appendFormat: @"%i", __accept];
  [ms appendString: @",resttime:"];
  [ms appendFormat: @"%i", __resttime];
  [ms appendString: @",language:"];
  [ms appendFormat: @"\"%@\"", __language];
  [ms appendString: @",topic:"];
  [ms appendFormat: @"\"%@\"", __topic];
  [ms appendString: @",asktopic:"];
  [ms appendFormat: @"%i", __asktopic];
  [ms appendString: @",askexpiry:"];
  [ms appendFormat: @"%i", __askexpiry];
  [ms appendString: @",intro:"];
  [ms appendFormat: @"%i", __intro];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_latest

- (id) initWithUserid: (NSString *) userid quesid: (int32_t) quesid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  __quesid = quesid;
  __quesid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  if ([decoder containsValueForKey: @"quesid"])
  {
    __quesid = [decoder decodeInt32ForKey: @"quesid"];
    __quesid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
  if (__quesid_isset)
  {
    [encoder encodeInt32: __quesid forKey: @"quesid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (int32_t) quesid {
  return __quesid;
}

- (void) setQuesid: (int32_t) quesid {
  __quesid = quesid;
  __quesid_isset = YES;
}

- (BOOL) quesidIsSet {
  return __quesid_isset;
}

- (void) unsetQuesid {
  __quesid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setQuesid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_latest"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__quesid_isset) {
    [outProtocol writeFieldBeginWithName: @"quesid" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __quesid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_latest("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @",quesid:"];
  [ms appendFormat: @"%i", __quesid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_delete

- (id) initWithUserid: (NSString *) userid forwardid: (int32_t) forwardid type: (int32_t) type
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  __forwardid = forwardid;
  __forwardid_isset = YES;
  __type = type;
  __type_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  if ([decoder containsValueForKey: @"type"])
  {
    __type = [decoder decodeInt32ForKey: @"type"];
    __type_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
  if (__type_isset)
  {
    [encoder encodeInt32: __type forKey: @"type"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (int32_t) type {
  return __type;
}

- (void) setType: (int32_t) type {
  __type = type;
  __type_isset = YES;
}

- (BOOL) typeIsSet {
  return __type_isset;
}

- (void) unsetType {
  __type_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setType: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_delete"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  if (__type_isset) {
    [outProtocol writeFieldBeginWithName: @"type" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __type];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_delete("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @",forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @",type:"];
  [ms appendFormat: @"%i", __type];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_relation

- (id) initWithMyuserid: (NSString *) myuserid otheruserid: (NSString *) otheruserid
{
  self = [super init];
  __myuserid = [myuserid retain];
  __myuserid_isset = YES;
  __otheruserid = [otheruserid retain];
  __otheruserid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"myuserid"])
  {
    __myuserid = [[decoder decodeObjectForKey: @"myuserid"] retain];
    __myuserid_isset = YES;
  }
  if ([decoder containsValueForKey: @"otheruserid"])
  {
    __otheruserid = [[decoder decodeObjectForKey: @"otheruserid"] retain];
    __otheruserid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__myuserid_isset)
  {
    [encoder encodeObject: __myuserid forKey: @"myuserid"];
  }
  if (__otheruserid_isset)
  {
    [encoder encodeObject: __otheruserid forKey: @"otheruserid"];
  }
}

- (void) dealloc
{
  [__myuserid release];
  [__otheruserid release];
  [super dealloc];
}

- (NSString *) myuserid {
  return [[__myuserid retain] autorelease];
}

- (void) setMyuserid: (NSString *) myuserid {
  [myuserid retain];
  [__myuserid release];
  __myuserid = myuserid;
  __myuserid_isset = YES;
}

- (BOOL) myuseridIsSet {
  return __myuserid_isset;
}

- (void) unsetMyuserid {
  [__myuserid release];
  __myuserid = nil;
  __myuserid_isset = NO;
}

- (NSString *) otheruserid {
  return [[__otheruserid retain] autorelease];
}

- (void) setOtheruserid: (NSString *) otheruserid {
  [otheruserid retain];
  [__otheruserid release];
  __otheruserid = otheruserid;
  __otheruserid_isset = YES;
}

- (BOOL) otheruseridIsSet {
  return __otheruserid_isset;
}

- (void) unsetOtheruserid {
  [__otheruserid release];
  __otheruserid = nil;
  __otheruserid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMyuserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setOtheruserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_relation"];
  if (__myuserid_isset) {
    if (__myuserid != nil) {
      [outProtocol writeFieldBeginWithName: @"myuserid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __myuserid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__otheruserid_isset) {
    if (__otheruserid != nil) {
      [outProtocol writeFieldBeginWithName: @"otheruserid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __otheruserid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_relation("];
  [ms appendString: @"myuserid:"];
  [ms appendFormat: @"\"%@\"", __myuserid];
  [ms appendString: @",otheruserid:"];
  [ms appendFormat: @"\"%@\"", __otheruserid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation s_tag

- (id) initWithUserid: (NSString *) userid tag: (NSString *) tag
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  __tag = [tag retain];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__userid release];
  [__tag release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (NSString *) tag {
  return [[__tag retain] autorelease];
}

- (void) setTag: (NSString *) tag {
  [tag retain];
  [__tag release];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTag: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"s_tag"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __tag];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"s_tag("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"\"%@\"", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface getTequilaTokenForQAforum_args : NSObject <NSCoding> {
}


- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

@end

@implementation getTequilaTokenForQAforum_args

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getTequilaTokenForQAforum_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getTequilaTokenForQAforum_args("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetTequilaTokenForQAforum_result : NSObject <NSCoding> {
  QATequilaToken * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) QATequilaToken * success;
#endif

- (id) initWithSuccess: (QATequilaToken *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (QATequilaToken *) success;
- (void) setSuccess: (QATequilaToken *) success;
- (BOOL) successIsSet;

@end

@implementation GetTequilaTokenForQAforum_result

- (id) initWithSuccess: (QATequilaToken *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (QATequilaToken *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (QATequilaToken *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          QATequilaToken *fieldValue = [[QATequilaToken alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetTequilaTokenForQAforum_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetTequilaTokenForQAforum_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface getSessionid_args : NSObject <NSCoding> {
  QATequilaToken * __token;

  BOOL __token_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=token, setter=setToken:) QATequilaToken * token;
#endif

- (id) initWithToken: (QATequilaToken *) token;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (QATequilaToken *) token;
- (void) setToken: (QATequilaToken *) token;
- (BOOL) tokenIsSet;

@end

@implementation getSessionid_args

- (id) initWithToken: (QATequilaToken *) token
{
  self = [super init];
  __token = [token retain];
  __token_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"token"])
  {
    __token = [[decoder decodeObjectForKey: @"token"] retain];
    __token_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__token_isset)
  {
    [encoder encodeObject: __token forKey: @"token"];
  }
}

- (void) dealloc
{
  [__token release];
  [super dealloc];
}

- (QATequilaToken *) token {
  return [[__token retain] autorelease];
}

- (void) setToken: (QATequilaToken *) token {
  [token retain];
  [__token release];
  __token = token;
  __token_isset = YES;
}

- (BOOL) tokenIsSet {
  return __token_isset;
}

- (void) unsetToken {
  [__token release];
  __token = nil;
  __token_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          QATequilaToken *fieldValue = [[QATequilaToken alloc] init];
          [fieldValue read: inProtocol];
          [self setToken: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSessionid_args"];
  if (__token_isset) {
    if (__token != nil) {
      [outProtocol writeFieldBeginWithName: @"token" type: TType_STRUCT fieldID: 1];
      [__token write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSessionid_args("];
  [ms appendString: @"token:"];
  [ms appendFormat: @"%@", __token];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetSessionid_result : NSObject <NSCoding> {
  s_session * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) s_session * success;
#endif

- (id) initWithSuccess: (s_session *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_session *) success;
- (void) setSuccess: (s_session *) success;
- (BOOL) successIsSet;

@end

@implementation GetSessionid_result

- (id) initWithSuccess: (s_session *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (s_session *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (s_session *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          s_session *fieldValue = [[s_session alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSessionid_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSessionid_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface updateSetting_args : NSObject <NSCoding> {
  s_session * __setting;

  BOOL __setting_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=setting, setter=setSetting:) s_session * setting;
#endif

- (id) initWithSetting: (s_session *) setting;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_session *) setting;
- (void) setSetting: (s_session *) setting;
- (BOOL) settingIsSet;

@end

@implementation updateSetting_args

- (id) initWithSetting: (s_session *) setting
{
  self = [super init];
  __setting = [setting retain];
  __setting_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"setting"])
  {
    __setting = [[decoder decodeObjectForKey: @"setting"] retain];
    __setting_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__setting_isset)
  {
    [encoder encodeObject: __setting forKey: @"setting"];
  }
}

- (void) dealloc
{
  [__setting release];
  [super dealloc];
}

- (s_session *) setting {
  return [[__setting retain] autorelease];
}

- (void) setSetting: (s_session *) setting {
  [setting retain];
  [__setting release];
  __setting = setting;
  __setting_isset = YES;
}

- (BOOL) settingIsSet {
  return __setting_isset;
}

- (void) unsetSetting {
  [__setting release];
  __setting = nil;
  __setting_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_session *fieldValue = [[s_session alloc] init];
          [fieldValue read: inProtocol];
          [self setSetting: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateSetting_args"];
  if (__setting_isset) {
    if (__setting != nil) {
      [outProtocol writeFieldBeginWithName: @"setting" type: TType_STRUCT fieldID: 1];
      [__setting write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateSetting_args("];
  [ms appendString: @"setting:"];
  [ms appendFormat: @"%@", __setting];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface UpdateSetting_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation UpdateSetting_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateSetting_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateSetting_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface acceptNotif_args : NSObject <NSCoding> {
  s_accept * __accept;

  BOOL __accept_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accept, setter=setAccept:) s_accept * accept;
#endif

- (id) initWithAccept: (s_accept *) accept;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_accept *) accept;
- (void) setAccept: (s_accept *) accept;
- (BOOL) acceptIsSet;

@end

@implementation acceptNotif_args

- (id) initWithAccept: (s_accept *) accept
{
  self = [super init];
  __accept = [accept retain];
  __accept_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accept"])
  {
    __accept = [[decoder decodeObjectForKey: @"accept"] retain];
    __accept_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accept_isset)
  {
    [encoder encodeObject: __accept forKey: @"accept"];
  }
}

- (void) dealloc
{
  [__accept release];
  [super dealloc];
}

- (s_accept *) accept {
  return [[__accept retain] autorelease];
}

- (void) setAccept: (s_accept *) accept {
  [accept retain];
  [__accept release];
  __accept = accept;
  __accept_isset = YES;
}

- (BOOL) acceptIsSet {
  return __accept_isset;
}

- (void) unsetAccept {
  [__accept release];
  __accept = nil;
  __accept_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_accept *fieldValue = [[s_accept alloc] init];
          [fieldValue read: inProtocol];
          [self setAccept: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"acceptNotif_args"];
  if (__accept_isset) {
    if (__accept != nil) {
      [outProtocol writeFieldBeginWithName: @"accept" type: TType_STRUCT fieldID: 1];
      [__accept write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"acceptNotif_args("];
  [ms appendString: @"accept:"];
  [ms appendFormat: @"%@", __accept];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface AcceptNotif_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation AcceptNotif_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AcceptNotif_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AcceptNotif_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface askQuestion_args : NSObject <NSCoding> {
  s_ask * __ask;

  BOOL __ask_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ask, setter=setAsk:) s_ask * ask;
#endif

- (id) initWithAsk: (s_ask *) ask;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_ask *) ask;
- (void) setAsk: (s_ask *) ask;
- (BOOL) askIsSet;

@end

@implementation askQuestion_args

- (id) initWithAsk: (s_ask *) ask
{
  self = [super init];
  __ask = [ask retain];
  __ask_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ask"])
  {
    __ask = [[decoder decodeObjectForKey: @"ask"] retain];
    __ask_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ask_isset)
  {
    [encoder encodeObject: __ask forKey: @"ask"];
  }
}

- (void) dealloc
{
  [__ask release];
  [super dealloc];
}

- (s_ask *) ask {
  return [[__ask retain] autorelease];
}

- (void) setAsk: (s_ask *) ask {
  [ask retain];
  [__ask release];
  __ask = ask;
  __ask_isset = YES;
}

- (BOOL) askIsSet {
  return __ask_isset;
}

- (void) unsetAsk {
  [__ask release];
  __ask = nil;
  __ask_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_ask *fieldValue = [[s_ask alloc] init];
          [fieldValue read: inProtocol];
          [self setAsk: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"askQuestion_args"];
  if (__ask_isset) {
    if (__ask != nil) {
      [outProtocol writeFieldBeginWithName: @"ask" type: TType_STRUCT fieldID: 1];
      [__ask write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"askQuestion_args("];
  [ms appendString: @"ask:"];
  [ms appendFormat: @"%@", __ask];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface AskQuestion_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation AskQuestion_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AskQuestion_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AskQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface answerQuestion_args : NSObject <NSCoding> {
  s_answer * __answer;

  BOOL __answer_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=answer, setter=setAnswer:) s_answer * answer;
#endif

- (id) initWithAnswer: (s_answer *) answer;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_answer *) answer;
- (void) setAnswer: (s_answer *) answer;
- (BOOL) answerIsSet;

@end

@implementation answerQuestion_args

- (id) initWithAnswer: (s_answer *) answer
{
  self = [super init];
  __answer = [answer retain];
  __answer_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"answer"])
  {
    __answer = [[decoder decodeObjectForKey: @"answer"] retain];
    __answer_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__answer_isset)
  {
    [encoder encodeObject: __answer forKey: @"answer"];
  }
}

- (void) dealloc
{
  [__answer release];
  [super dealloc];
}

- (s_answer *) answer {
  return [[__answer retain] autorelease];
}

- (void) setAnswer: (s_answer *) answer {
  [answer retain];
  [__answer release];
  __answer = answer;
  __answer_isset = YES;
}

- (BOOL) answerIsSet {
  return __answer_isset;
}

- (void) unsetAnswer {
  [__answer release];
  __answer = nil;
  __answer_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_answer *fieldValue = [[s_answer alloc] init];
          [fieldValue read: inProtocol];
          [self setAnswer: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"answerQuestion_args"];
  if (__answer_isset) {
    if (__answer != nil) {
      [outProtocol writeFieldBeginWithName: @"answer" type: TType_STRUCT fieldID: 1];
      [__answer write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"answerQuestion_args("];
  [ms appendString: @"answer:"];
  [ms appendFormat: @"%@", __answer];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface AnswerQuestion_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation AnswerQuestion_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AnswerQuestion_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AnswerQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface feedbackQuestion_args : NSObject <NSCoding> {
  s_feedback * __feedback;

  BOOL __feedback_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=feedback, setter=setFeedback:) s_feedback * feedback;
#endif

- (id) initWithFeedback: (s_feedback *) feedback;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_feedback *) feedback;
- (void) setFeedback: (s_feedback *) feedback;
- (BOOL) feedbackIsSet;

@end

@implementation feedbackQuestion_args

- (id) initWithFeedback: (s_feedback *) feedback
{
  self = [super init];
  __feedback = [feedback retain];
  __feedback_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"feedback"])
  {
    __feedback = [[decoder decodeObjectForKey: @"feedback"] retain];
    __feedback_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__feedback_isset)
  {
    [encoder encodeObject: __feedback forKey: @"feedback"];
  }
}

- (void) dealloc
{
  [__feedback release];
  [super dealloc];
}

- (s_feedback *) feedback {
  return [[__feedback retain] autorelease];
}

- (void) setFeedback: (s_feedback *) feedback {
  [feedback retain];
  [__feedback release];
  __feedback = feedback;
  __feedback_isset = YES;
}

- (BOOL) feedbackIsSet {
  return __feedback_isset;
}

- (void) unsetFeedback {
  [__feedback release];
  __feedback = nil;
  __feedback_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_feedback *fieldValue = [[s_feedback alloc] init];
          [fieldValue read: inProtocol];
          [self setFeedback: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"feedbackQuestion_args"];
  if (__feedback_isset) {
    if (__feedback != nil) {
      [outProtocol writeFieldBeginWithName: @"feedback" type: TType_STRUCT fieldID: 1];
      [__feedback write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"feedbackQuestion_args("];
  [ms appendString: @"feedback:"];
  [ms appendFormat: @"%@", __feedback];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface FeedbackQuestion_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation FeedbackQuestion_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FeedbackQuestion_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FeedbackQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface requestQuestion_args : NSObject <NSCoding> {
  s_request * __request;

  BOOL __request_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=request, setter=setRequest:) s_request * request;
#endif

- (id) initWithRequest: (s_request *) request;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_request *) request;
- (void) setRequest: (s_request *) request;
- (BOOL) requestIsSet;

@end

@implementation requestQuestion_args

- (id) initWithRequest: (s_request *) request
{
  self = [super init];
  __request = [request retain];
  __request_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"request"])
  {
    __request = [[decoder decodeObjectForKey: @"request"] retain];
    __request_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__request_isset)
  {
    [encoder encodeObject: __request forKey: @"request"];
  }
}

- (void) dealloc
{
  [__request release];
  [super dealloc];
}

- (s_request *) request {
  return [[__request retain] autorelease];
}

- (void) setRequest: (s_request *) request {
  [request retain];
  [__request release];
  __request = request;
  __request_isset = YES;
}

- (BOOL) requestIsSet {
  return __request_isset;
}

- (void) unsetRequest {
  [__request release];
  __request = nil;
  __request_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_request *fieldValue = [[s_request alloc] init];
          [fieldValue read: inProtocol];
          [self setRequest: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"requestQuestion_args"];
  if (__request_isset) {
    if (__request != nil) {
      [outProtocol writeFieldBeginWithName: @"request" type: TType_STRUCT fieldID: 1];
      [__request write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"requestQuestion_args("];
  [ms appendString: @"request:"];
  [ms appendFormat: @"%@", __request];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface RequestQuestion_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation RequestQuestion_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RequestQuestion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RequestQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface reportQuestion_args : NSObject <NSCoding> {
  s_report * __report;

  BOOL __report_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=report, setter=setReport:) s_report * report;
#endif

- (id) initWithReport: (s_report *) report;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_report *) report;
- (void) setReport: (s_report *) report;
- (BOOL) reportIsSet;

@end

@implementation reportQuestion_args

- (id) initWithReport: (s_report *) report
{
  self = [super init];
  __report = [report retain];
  __report_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"report"])
  {
    __report = [[decoder decodeObjectForKey: @"report"] retain];
    __report_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__report_isset)
  {
    [encoder encodeObject: __report forKey: @"report"];
  }
}

- (void) dealloc
{
  [__report release];
  [super dealloc];
}

- (s_report *) report {
  return [[__report retain] autorelease];
}

- (void) setReport: (s_report *) report {
  [report retain];
  [__report release];
  __report = report;
  __report_isset = YES;
}

- (BOOL) reportIsSet {
  return __report_isset;
}

- (void) unsetReport {
  [__report release];
  __report = nil;
  __report_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_report *fieldValue = [[s_report alloc] init];
          [fieldValue read: inProtocol];
          [self setReport: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"reportQuestion_args"];
  if (__report_isset) {
    if (__report != nil) {
      [outProtocol writeFieldBeginWithName: @"report" type: TType_STRUCT fieldID: 1];
      [__report write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"reportQuestion_args("];
  [ms appendString: @"report:"];
  [ms appendFormat: @"%@", __report];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface ReportQuestion_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation ReportQuestion_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ReportQuestion_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ReportQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface requestInformation_args : NSObject <NSCoding> {
  NSString * __sessionid;

  BOOL __sessionid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=sessionid, setter=setSessionid:) NSString * sessionid;
#endif

- (id) initWithSessionid: (NSString *) sessionid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) sessionid;
- (void) setSessionid: (NSString *) sessionid;
- (BOOL) sessionidIsSet;

@end

@implementation requestInformation_args

- (id) initWithSessionid: (NSString *) sessionid
{
  self = [super init];
  __sessionid = [sessionid retain];
  __sessionid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessionid"])
  {
    __sessionid = [[decoder decodeObjectForKey: @"sessionid"] retain];
    __sessionid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessionid_isset)
  {
    [encoder encodeObject: __sessionid forKey: @"sessionid"];
  }
}

- (void) dealloc
{
  [__sessionid release];
  [super dealloc];
}

- (NSString *) sessionid {
  return [[__sessionid retain] autorelease];
}

- (void) setSessionid: (NSString *) sessionid {
  [sessionid retain];
  [__sessionid release];
  __sessionid = sessionid;
  __sessionid_isset = YES;
}

- (BOOL) sessionidIsSet {
  return __sessionid_isset;
}

- (void) unsetSessionid {
  [__sessionid release];
  __sessionid = nil;
  __sessionid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSessionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"requestInformation_args"];
  if (__sessionid_isset) {
    if (__sessionid != nil) {
      [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __sessionid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"requestInformation_args("];
  [ms appendString: @"sessionid:"];
  [ms appendFormat: @"\"%@\"", __sessionid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface RequestInformation_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation RequestInformation_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RequestInformation_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RequestInformation_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface myQuestions_args : NSObject <NSCoding> {
  NSString * __userid;

  BOOL __userid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userid, setter=setUserid:) NSString * userid;
#endif

- (id) initWithUserid: (NSString *) userid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) userid;
- (void) setUserid: (NSString *) userid;
- (BOOL) useridIsSet;

@end

@implementation myQuestions_args

- (id) initWithUserid: (NSString *) userid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"myQuestions_args"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"myQuestions_args("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MyQuestions_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation MyQuestions_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MyQuestions_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MyQuestions_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface oneQuestion_args : NSObject <NSCoding> {
  int32_t __questionid;

  BOOL __questionid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=questionid, setter=setQuestionid:) int32_t questionid;
#endif

- (id) initWithQuestionid: (int32_t) questionid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) questionid;
- (void) setQuestionid: (int32_t) questionid;
- (BOOL) questionidIsSet;

@end

@implementation oneQuestion_args

- (id) initWithQuestionid: (int32_t) questionid
{
  self = [super init];
  __questionid = questionid;
  __questionid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"questionid"])
  {
    __questionid = [decoder decodeInt32ForKey: @"questionid"];
    __questionid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__questionid_isset)
  {
    [encoder encodeInt32: __questionid forKey: @"questionid"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) questionid {
  return __questionid;
}

- (void) setQuestionid: (int32_t) questionid {
  __questionid = questionid;
  __questionid_isset = YES;
}

- (BOOL) questionidIsSet {
  return __questionid_isset;
}

- (void) unsetQuestionid {
  __questionid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setQuestionid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"oneQuestion_args"];
  if (__questionid_isset) {
    [outProtocol writeFieldBeginWithName: @"questionid" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __questionid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"oneQuestion_args("];
  [ms appendString: @"questionid:"];
  [ms appendFormat: @"%i", __questionid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface OneQuestion_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation OneQuestion_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"OneQuestion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"OneQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface myAnswers_args : NSObject <NSCoding> {
  NSString * __userid;

  BOOL __userid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userid, setter=setUserid:) NSString * userid;
#endif

- (id) initWithUserid: (NSString *) userid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) userid;
- (void) setUserid: (NSString *) userid;
- (BOOL) useridIsSet;

@end

@implementation myAnswers_args

- (id) initWithUserid: (NSString *) userid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"myAnswers_args"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"myAnswers_args("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MyAnswers_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation MyAnswers_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MyAnswers_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MyAnswers_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface oneAnswer_args : NSObject <NSCoding> {
  int32_t __forwardid;

  BOOL __forwardid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=forwardid, setter=setForwardid:) int32_t forwardid;
#endif

- (id) initWithForwardid: (int32_t) forwardid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) forwardid;
- (void) setForwardid: (int32_t) forwardid;
- (BOOL) forwardidIsSet;

@end

@implementation oneAnswer_args

- (id) initWithForwardid: (int32_t) forwardid
{
  self = [super init];
  __forwardid = forwardid;
  __forwardid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"forwardid"])
  {
    __forwardid = [decoder decodeInt32ForKey: @"forwardid"];
    __forwardid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__forwardid_isset)
  {
    [encoder encodeInt32: __forwardid forKey: @"forwardid"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) forwardid {
  return __forwardid;
}

- (void) setForwardid: (int32_t) forwardid {
  __forwardid = forwardid;
  __forwardid_isset = YES;
}

- (BOOL) forwardidIsSet {
  return __forwardid_isset;
}

- (void) unsetForwardid {
  __forwardid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setForwardid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"oneAnswer_args"];
  if (__forwardid_isset) {
    [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __forwardid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"oneAnswer_args("];
  [ms appendString: @"forwardid:"];
  [ms appendFormat: @"%i", __forwardid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface OneAnswer_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation OneAnswer_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"OneAnswer_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"OneAnswer_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface latestQuestions_args : NSObject <NSCoding> {
  NSString * __userid;

  BOOL __userid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userid, setter=setUserid:) NSString * userid;
#endif

- (id) initWithUserid: (NSString *) userid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) userid;
- (void) setUserid: (NSString *) userid;
- (BOOL) useridIsSet;

@end

@implementation latestQuestions_args

- (id) initWithUserid: (NSString *) userid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"latestQuestions_args"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"latestQuestions_args("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LatestQuestions_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation LatestQuestions_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"LatestQuestions_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"LatestQuestions_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface oneLatestQuestion_args : NSObject <NSCoding> {
  s_latest * __onelatest;

  BOOL __onelatest_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=onelatest, setter=setOnelatest:) s_latest * onelatest;
#endif

- (id) initWithOnelatest: (s_latest *) onelatest;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_latest *) onelatest;
- (void) setOnelatest: (s_latest *) onelatest;
- (BOOL) onelatestIsSet;

@end

@implementation oneLatestQuestion_args

- (id) initWithOnelatest: (s_latest *) onelatest
{
  self = [super init];
  __onelatest = [onelatest retain];
  __onelatest_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"onelatest"])
  {
    __onelatest = [[decoder decodeObjectForKey: @"onelatest"] retain];
    __onelatest_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__onelatest_isset)
  {
    [encoder encodeObject: __onelatest forKey: @"onelatest"];
  }
}

- (void) dealloc
{
  [__onelatest release];
  [super dealloc];
}

- (s_latest *) onelatest {
  return [[__onelatest retain] autorelease];
}

- (void) setOnelatest: (s_latest *) onelatest {
  [onelatest retain];
  [__onelatest release];
  __onelatest = onelatest;
  __onelatest_isset = YES;
}

- (BOOL) onelatestIsSet {
  return __onelatest_isset;
}

- (void) unsetOnelatest {
  [__onelatest release];
  __onelatest = nil;
  __onelatest_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_latest *fieldValue = [[s_latest alloc] init];
          [fieldValue read: inProtocol];
          [self setOnelatest: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"oneLatestQuestion_args"];
  if (__onelatest_isset) {
    if (__onelatest != nil) {
      [outProtocol writeFieldBeginWithName: @"onelatest" type: TType_STRUCT fieldID: 1];
      [__onelatest write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"oneLatestQuestion_args("];
  [ms appendString: @"onelatest:"];
  [ms appendFormat: @"%@", __onelatest];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface OneLatestQuestion_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation OneLatestQuestion_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"OneLatestQuestion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"OneLatestQuestion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface pendingNotifications_args : NSObject <NSCoding> {
  NSString * __userid;

  BOOL __userid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userid, setter=setUserid:) NSString * userid;
#endif

- (id) initWithUserid: (NSString *) userid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) userid;
- (void) setUserid: (NSString *) userid;
- (BOOL) useridIsSet;

@end

@implementation pendingNotifications_args

- (id) initWithUserid: (NSString *) userid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"pendingNotifications_args"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"pendingNotifications_args("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface PendingNotifications_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation PendingNotifications_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"PendingNotifications_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"PendingNotifications_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface deleteNotification_args : NSObject <NSCoding> {
  s_delete * __deleteinfo;

  BOOL __deleteinfo_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=deleteinfo, setter=setDeleteinfo:) s_delete * deleteinfo;
#endif

- (id) initWithDeleteinfo: (s_delete *) deleteinfo;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_delete *) deleteinfo;
- (void) setDeleteinfo: (s_delete *) deleteinfo;
- (BOOL) deleteinfoIsSet;

@end

@implementation deleteNotification_args

- (id) initWithDeleteinfo: (s_delete *) deleteinfo
{
  self = [super init];
  __deleteinfo = [deleteinfo retain];
  __deleteinfo_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"deleteinfo"])
  {
    __deleteinfo = [[decoder decodeObjectForKey: @"deleteinfo"] retain];
    __deleteinfo_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__deleteinfo_isset)
  {
    [encoder encodeObject: __deleteinfo forKey: @"deleteinfo"];
  }
}

- (void) dealloc
{
  [__deleteinfo release];
  [super dealloc];
}

- (s_delete *) deleteinfo {
  return [[__deleteinfo retain] autorelease];
}

- (void) setDeleteinfo: (s_delete *) deleteinfo {
  [deleteinfo retain];
  [__deleteinfo release];
  __deleteinfo = deleteinfo;
  __deleteinfo_isset = YES;
}

- (BOOL) deleteinfoIsSet {
  return __deleteinfo_isset;
}

- (void) unsetDeleteinfo {
  [__deleteinfo release];
  __deleteinfo = nil;
  __deleteinfo_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_delete *fieldValue = [[s_delete alloc] init];
          [fieldValue read: inProtocol];
          [self setDeleteinfo: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"deleteNotification_args"];
  if (__deleteinfo_isset) {
    if (__deleteinfo != nil) {
      [outProtocol writeFieldBeginWithName: @"deleteinfo" type: TType_STRUCT fieldID: 1];
      [__deleteinfo write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"deleteNotification_args("];
  [ms appendString: @"deleteinfo:"];
  [ms appendFormat: @"%@", __deleteinfo];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface DeleteNotification_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation DeleteNotification_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DeleteNotification_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DeleteNotification_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface questionMatching_args : NSObject <NSCoding> {
  NSString * __question;

  BOOL __question_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=question, setter=setQuestion:) NSString * question;
#endif

- (id) initWithQuestion: (NSString *) question;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) question;
- (void) setQuestion: (NSString *) question;
- (BOOL) questionIsSet;

@end

@implementation questionMatching_args

- (id) initWithQuestion: (NSString *) question
{
  self = [super init];
  __question = [question retain];
  __question_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"question"])
  {
    __question = [[decoder decodeObjectForKey: @"question"] retain];
    __question_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__question_isset)
  {
    [encoder encodeObject: __question forKey: @"question"];
  }
}

- (void) dealloc
{
  [__question release];
  [super dealloc];
}

- (NSString *) question {
  return [[__question retain] autorelease];
}

- (void) setQuestion: (NSString *) question {
  [question retain];
  [__question release];
  __question = question;
  __question_isset = YES;
}

- (BOOL) questionIsSet {
  return __question_isset;
}

- (void) unsetQuestion {
  [__question release];
  __question = nil;
  __question_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setQuestion: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"questionMatching_args"];
  if (__question_isset) {
    if (__question != nil) {
      [outProtocol writeFieldBeginWithName: @"question" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __question];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"questionMatching_args("];
  [ms appendString: @"question:"];
  [ms appendFormat: @"\"%@\"", __question];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface QuestionMatching_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation QuestionMatching_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"QuestionMatching_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"QuestionMatching_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface relationship_args : NSObject <NSCoding> {
  s_relation * __relation;

  BOOL __relation_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=relation, setter=setRelation:) s_relation * relation;
#endif

- (id) initWithRelation: (s_relation *) relation;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_relation *) relation;
- (void) setRelation: (s_relation *) relation;
- (BOOL) relationIsSet;

@end

@implementation relationship_args

- (id) initWithRelation: (s_relation *) relation
{
  self = [super init];
  __relation = [relation retain];
  __relation_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"relation"])
  {
    __relation = [[decoder decodeObjectForKey: @"relation"] retain];
    __relation_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__relation_isset)
  {
    [encoder encodeObject: __relation forKey: @"relation"];
  }
}

- (void) dealloc
{
  [__relation release];
  [super dealloc];
}

- (s_relation *) relation {
  return [[__relation retain] autorelease];
}

- (void) setRelation: (s_relation *) relation {
  [relation retain];
  [__relation release];
  __relation = relation;
  __relation_isset = YES;
}

- (BOOL) relationIsSet {
  return __relation_isset;
}

- (void) unsetRelation {
  [__relation release];
  __relation = nil;
  __relation_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_relation *fieldValue = [[s_relation alloc] init];
          [fieldValue read: inProtocol];
          [self setRelation: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"relationship_args"];
  if (__relation_isset) {
    if (__relation != nil) {
      [outProtocol writeFieldBeginWithName: @"relation" type: TType_STRUCT fieldID: 1];
      [__relation write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"relationship_args("];
  [ms appendString: @"relation:"];
  [ms appendFormat: @"%@", __relation];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Relationship_result : NSObject <NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

@end

@implementation Relationship_result

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Relationship_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Relationship_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface tagInterested_args : NSObject <NSCoding> {
  s_tag * __taguser;

  BOOL __taguser_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=taguser, setter=setTaguser:) s_tag * taguser;
#endif

- (id) initWithTaguser: (s_tag *) taguser;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (s_tag *) taguser;
- (void) setTaguser: (s_tag *) taguser;
- (BOOL) taguserIsSet;

@end

@implementation tagInterested_args

- (id) initWithTaguser: (s_tag *) taguser
{
  self = [super init];
  __taguser = [taguser retain];
  __taguser_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"taguser"])
  {
    __taguser = [[decoder decodeObjectForKey: @"taguser"] retain];
    __taguser_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__taguser_isset)
  {
    [encoder encodeObject: __taguser forKey: @"taguser"];
  }
}

- (void) dealloc
{
  [__taguser release];
  [super dealloc];
}

- (s_tag *) taguser {
  return [[__taguser retain] autorelease];
}

- (void) setTaguser: (s_tag *) taguser {
  [taguser retain];
  [__taguser release];
  __taguser = taguser;
  __taguser_isset = YES;
}

- (BOOL) taguserIsSet {
  return __taguser_isset;
}

- (void) unsetTaguser {
  [__taguser release];
  __taguser = nil;
  __taguser_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          s_tag *fieldValue = [[s_tag alloc] init];
          [fieldValue read: inProtocol];
          [self setTaguser: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"tagInterested_args"];
  if (__taguser_isset) {
    if (__taguser != nil) {
      [outProtocol writeFieldBeginWithName: @"taguser" type: TType_STRUCT fieldID: 1];
      [__taguser write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"tagInterested_args("];
  [ms appendString: @"taguser:"];
  [ms appendFormat: @"%@", __taguser];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface TagInterested_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation TagInterested_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"TagInterested_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"TagInterested_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface closeIntro_args : NSObject <NSCoding> {
  NSString * __userid;

  BOOL __userid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userid, setter=setUserid:) NSString * userid;
#endif

- (id) initWithUserid: (NSString *) userid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) userid;
- (void) setUserid: (NSString *) userid;
- (BOOL) useridIsSet;

@end

@implementation closeIntro_args

- (id) initWithUserid: (NSString *) userid
{
  self = [super init];
  __userid = [userid retain];
  __userid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userid"])
  {
    __userid = [[decoder decodeObjectForKey: @"userid"] retain];
    __userid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userid_isset)
  {
    [encoder encodeObject: __userid forKey: @"userid"];
  }
}

- (void) dealloc
{
  [__userid release];
  [super dealloc];
}

- (NSString *) userid {
  return [[__userid retain] autorelease];
}

- (void) setUserid: (NSString *) userid {
  [userid retain];
  [__userid release];
  __userid = userid;
  __userid_isset = YES;
}

- (BOOL) useridIsSet {
  return __userid_isset;
}

- (void) unsetUserid {
  [__userid release];
  __userid = nil;
  __userid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setUserid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"closeIntro_args"];
  if (__userid_isset) {
    if (__userid != nil) {
      [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __userid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"closeIntro_args("];
  [ms appendString: @"userid:"];
  [ms appendFormat: @"\"%@\"", __userid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface CloseIntro_result : NSObject <NSCoding> {
  int32_t __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
#endif

- (id) initWithSuccess: (int32_t) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

@end

@implementation CloseIntro_result

- (id) initWithSuccess: (int32_t) success
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CloseIntro_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CloseIntro_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation QAforumServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  [super init];
  inProtocol = [anInProtocol retain];
  outProtocol = [anOutProtocol retain];
  return self;
}

- (void) dealloc
{
  [inProtocol release];
  [outProtocol release];
  [super dealloc];
}

- (void) send_getTequilaTokenForQAforum
{
  [outProtocol writeMessageBeginWithName: @"getTequilaTokenForQAforum" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getTequilaTokenForQAforum_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (QATequilaToken *) recv_getTequilaTokenForQAforum
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetTequilaTokenForQAforum_result * result = [[[GetTequilaTokenForQAforum_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getTequilaTokenForQAforum failed: unknown result"];
}

- (QATequilaToken *) getTequilaTokenForQAforum
{
  [self send_getTequilaTokenForQAforum];
  return [self recv_getTequilaTokenForQAforum];
}

- (void) send_getSessionid: (QATequilaToken *) token
{
  [outProtocol writeMessageBeginWithName: @"getSessionid" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSessionid_args"];
  if (token != nil)  {
    [outProtocol writeFieldBeginWithName: @"token" type: TType_STRUCT fieldID: 1];
    [token write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (s_session *) recv_getSessionid
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetSessionid_result * result = [[[GetSessionid_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSessionid failed: unknown result"];
}

- (s_session *) getSessionid: (QATequilaToken *) token
{
  [self send_getSessionid: token];
  return [self recv_getSessionid];
}

- (void) send_updateSetting: (s_session *) setting
{
  [outProtocol writeMessageBeginWithName: @"updateSetting" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateSetting_args"];
  if (setting != nil)  {
    [outProtocol writeFieldBeginWithName: @"setting" type: TType_STRUCT fieldID: 1];
    [setting write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateSetting
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  UpdateSetting_result * result = [[[UpdateSetting_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateSetting failed: unknown result"];
}

- (int32_t) updateSetting: (s_session *) setting
{
  [self send_updateSetting: setting];
  return [self recv_updateSetting];
}

- (void) send_acceptNotif: (s_accept *) accept
{
  [outProtocol writeMessageBeginWithName: @"acceptNotif" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"acceptNotif_args"];
  if (accept != nil)  {
    [outProtocol writeFieldBeginWithName: @"accept" type: TType_STRUCT fieldID: 1];
    [accept write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_acceptNotif
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  AcceptNotif_result * result = [[[AcceptNotif_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"acceptNotif failed: unknown result"];
}

- (NSString *) acceptNotif: (s_accept *) accept
{
  [self send_acceptNotif: accept];
  return [self recv_acceptNotif];
}

- (void) send_askQuestion: (s_ask *) ask
{
  [outProtocol writeMessageBeginWithName: @"askQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"askQuestion_args"];
  if (ask != nil)  {
    [outProtocol writeFieldBeginWithName: @"ask" type: TType_STRUCT fieldID: 1];
    [ask write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_askQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  AskQuestion_result * result = [[[AskQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"askQuestion failed: unknown result"];
}

- (int32_t) askQuestion: (s_ask *) ask
{
  [self send_askQuestion: ask];
  return [self recv_askQuestion];
}

- (void) send_answerQuestion: (s_answer *) answer
{
  [outProtocol writeMessageBeginWithName: @"answerQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"answerQuestion_args"];
  if (answer != nil)  {
    [outProtocol writeFieldBeginWithName: @"answer" type: TType_STRUCT fieldID: 1];
    [answer write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_answerQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  AnswerQuestion_result * result = [[[AnswerQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"answerQuestion failed: unknown result"];
}

- (int32_t) answerQuestion: (s_answer *) answer
{
  [self send_answerQuestion: answer];
  return [self recv_answerQuestion];
}

- (void) send_feedbackQuestion: (s_feedback *) feedback
{
  [outProtocol writeMessageBeginWithName: @"feedbackQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"feedbackQuestion_args"];
  if (feedback != nil)  {
    [outProtocol writeFieldBeginWithName: @"feedback" type: TType_STRUCT fieldID: 1];
    [feedback write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_feedbackQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  FeedbackQuestion_result * result = [[[FeedbackQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"feedbackQuestion failed: unknown result"];
}

- (int32_t) feedbackQuestion: (s_feedback *) feedback
{
  [self send_feedbackQuestion: feedback];
  return [self recv_feedbackQuestion];
}

- (void) send_requestQuestion: (s_request *) request
{
  [outProtocol writeMessageBeginWithName: @"requestQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"requestQuestion_args"];
  if (request != nil)  {
    [outProtocol writeFieldBeginWithName: @"request" type: TType_STRUCT fieldID: 1];
    [request write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_requestQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  RequestQuestion_result * result = [[[RequestQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"requestQuestion failed: unknown result"];
}

- (NSString *) requestQuestion: (s_request *) request
{
  [self send_requestQuestion: request];
  return [self recv_requestQuestion];
}

- (void) send_reportQuestion: (s_report *) report
{
  [outProtocol writeMessageBeginWithName: @"reportQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"reportQuestion_args"];
  if (report != nil)  {
    [outProtocol writeFieldBeginWithName: @"report" type: TType_STRUCT fieldID: 1];
    [report write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_reportQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  ReportQuestion_result * result = [[[ReportQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"reportQuestion failed: unknown result"];
}

- (int32_t) reportQuestion: (s_report *) report
{
  [self send_reportQuestion: report];
  return [self recv_reportQuestion];
}

- (void) send_requestInformation: (NSString *) sessionid
{
  [outProtocol writeMessageBeginWithName: @"requestInformation" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"requestInformation_args"];
  if (sessionid != nil)  {
    [outProtocol writeFieldBeginWithName: @"sessionid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: sessionid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_requestInformation
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  RequestInformation_result * result = [[[RequestInformation_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"requestInformation failed: unknown result"];
}

- (NSString *) requestInformation: (NSString *) sessionid
{
  [self send_requestInformation: sessionid];
  return [self recv_requestInformation];
}

- (void) send_myQuestions: (NSString *) userid
{
  [outProtocol writeMessageBeginWithName: @"myQuestions" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"myQuestions_args"];
  if (userid != nil)  {
    [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: userid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_myQuestions
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MyQuestions_result * result = [[[MyQuestions_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"myQuestions failed: unknown result"];
}

- (NSString *) myQuestions: (NSString *) userid
{
  [self send_myQuestions: userid];
  return [self recv_myQuestions];
}

- (void) send_oneQuestion: (int32_t) questionid
{
  [outProtocol writeMessageBeginWithName: @"oneQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"oneQuestion_args"];
  [outProtocol writeFieldBeginWithName: @"questionid" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: questionid];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_oneQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  OneQuestion_result * result = [[[OneQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"oneQuestion failed: unknown result"];
}

- (NSString *) oneQuestion: (int32_t) questionid
{
  [self send_oneQuestion: questionid];
  return [self recv_oneQuestion];
}

- (void) send_myAnswers: (NSString *) userid
{
  [outProtocol writeMessageBeginWithName: @"myAnswers" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"myAnswers_args"];
  if (userid != nil)  {
    [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: userid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_myAnswers
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MyAnswers_result * result = [[[MyAnswers_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"myAnswers failed: unknown result"];
}

- (NSString *) myAnswers: (NSString *) userid
{
  [self send_myAnswers: userid];
  return [self recv_myAnswers];
}

- (void) send_oneAnswer: (int32_t) forwardid
{
  [outProtocol writeMessageBeginWithName: @"oneAnswer" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"oneAnswer_args"];
  [outProtocol writeFieldBeginWithName: @"forwardid" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: forwardid];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_oneAnswer
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  OneAnswer_result * result = [[[OneAnswer_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"oneAnswer failed: unknown result"];
}

- (NSString *) oneAnswer: (int32_t) forwardid
{
  [self send_oneAnswer: forwardid];
  return [self recv_oneAnswer];
}

- (void) send_latestQuestions: (NSString *) userid
{
  [outProtocol writeMessageBeginWithName: @"latestQuestions" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"latestQuestions_args"];
  if (userid != nil)  {
    [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: userid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_latestQuestions
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LatestQuestions_result * result = [[[LatestQuestions_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"latestQuestions failed: unknown result"];
}

- (NSString *) latestQuestions: (NSString *) userid
{
  [self send_latestQuestions: userid];
  return [self recv_latestQuestions];
}

- (void) send_oneLatestQuestion: (s_latest *) onelatest
{
  [outProtocol writeMessageBeginWithName: @"oneLatestQuestion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"oneLatestQuestion_args"];
  if (onelatest != nil)  {
    [outProtocol writeFieldBeginWithName: @"onelatest" type: TType_STRUCT fieldID: 1];
    [onelatest write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_oneLatestQuestion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  OneLatestQuestion_result * result = [[[OneLatestQuestion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"oneLatestQuestion failed: unknown result"];
}

- (NSString *) oneLatestQuestion: (s_latest *) onelatest
{
  [self send_oneLatestQuestion: onelatest];
  return [self recv_oneLatestQuestion];
}

- (void) send_pendingNotifications: (NSString *) userid
{
  [outProtocol writeMessageBeginWithName: @"pendingNotifications" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"pendingNotifications_args"];
  if (userid != nil)  {
    [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: userid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_pendingNotifications
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  PendingNotifications_result * result = [[[PendingNotifications_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"pendingNotifications failed: unknown result"];
}

- (NSString *) pendingNotifications: (NSString *) userid
{
  [self send_pendingNotifications: userid];
  return [self recv_pendingNotifications];
}

- (void) send_deleteNotification: (s_delete *) deleteinfo
{
  [outProtocol writeMessageBeginWithName: @"deleteNotification" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"deleteNotification_args"];
  if (deleteinfo != nil)  {
    [outProtocol writeFieldBeginWithName: @"deleteinfo" type: TType_STRUCT fieldID: 1];
    [deleteinfo write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_deleteNotification
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  DeleteNotification_result * result = [[[DeleteNotification_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"deleteNotification failed: unknown result"];
}

- (int32_t) deleteNotification: (s_delete *) deleteinfo
{
  [self send_deleteNotification: deleteinfo];
  return [self recv_deleteNotification];
}

- (void) send_questionMatching: (NSString *) question
{
  [outProtocol writeMessageBeginWithName: @"questionMatching" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"questionMatching_args"];
  if (question != nil)  {
    [outProtocol writeFieldBeginWithName: @"question" type: TType_STRING fieldID: 1];
    [outProtocol writeString: question];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_questionMatching
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  QuestionMatching_result * result = [[[QuestionMatching_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"questionMatching failed: unknown result"];
}

- (NSString *) questionMatching: (NSString *) question
{
  [self send_questionMatching: question];
  return [self recv_questionMatching];
}

- (void) send_relationship: (s_relation *) relation
{
  [outProtocol writeMessageBeginWithName: @"relationship" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"relationship_args"];
  if (relation != nil)  {
    [outProtocol writeFieldBeginWithName: @"relation" type: TType_STRUCT fieldID: 1];
    [relation write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_relationship
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  Relationship_result * result = [[[Relationship_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"relationship failed: unknown result"];
}

- (NSString *) relationship: (s_relation *) relation
{
  [self send_relationship: relation];
  return [self recv_relationship];
}

- (void) send_tagInterested: (s_tag *) taguser
{
  [outProtocol writeMessageBeginWithName: @"tagInterested" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"tagInterested_args"];
  if (taguser != nil)  {
    [outProtocol writeFieldBeginWithName: @"taguser" type: TType_STRUCT fieldID: 1];
    [taguser write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_tagInterested
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  TagInterested_result * result = [[[TagInterested_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"tagInterested failed: unknown result"];
}

- (int32_t) tagInterested: (s_tag *) taguser
{
  [self send_tagInterested: taguser];
  return [self recv_tagInterested];
}

- (void) send_closeIntro: (NSString *) userid
{
  [outProtocol writeMessageBeginWithName: @"closeIntro" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"closeIntro_args"];
  if (userid != nil)  {
    [outProtocol writeFieldBeginWithName: @"userid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: userid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_closeIntro
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  CloseIntro_result * result = [[[CloseIntro_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"closeIntro failed: unknown result"];
}

- (int32_t) closeIntro: (NSString *) userid
{
  [self send_closeIntro: userid];
  return [self recv_closeIntro];
}

@end

@implementation QAforumServiceProcessor

- (id) initWithQAforumService: (id <QAforumService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain];
  mMethodMap = [[NSMutableDictionary dictionary] retain];
  {
    SEL s = @selector(process_getTequilaTokenForQAforum_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getTequilaTokenForQAforum"];
  }
  {
    SEL s = @selector(process_getSessionid_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSessionid"];
  }
  {
    SEL s = @selector(process_updateSetting_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateSetting"];
  }
  {
    SEL s = @selector(process_acceptNotif_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"acceptNotif"];
  }
  {
    SEL s = @selector(process_askQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"askQuestion"];
  }
  {
    SEL s = @selector(process_answerQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"answerQuestion"];
  }
  {
    SEL s = @selector(process_feedbackQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"feedbackQuestion"];
  }
  {
    SEL s = @selector(process_requestQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"requestQuestion"];
  }
  {
    SEL s = @selector(process_reportQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"reportQuestion"];
  }
  {
    SEL s = @selector(process_requestInformation_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"requestInformation"];
  }
  {
    SEL s = @selector(process_myQuestions_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"myQuestions"];
  }
  {
    SEL s = @selector(process_oneQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"oneQuestion"];
  }
  {
    SEL s = @selector(process_myAnswers_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"myAnswers"];
  }
  {
    SEL s = @selector(process_oneAnswer_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"oneAnswer"];
  }
  {
    SEL s = @selector(process_latestQuestions_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"latestQuestions"];
  }
  {
    SEL s = @selector(process_oneLatestQuestion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"oneLatestQuestion"];
  }
  {
    SEL s = @selector(process_pendingNotifications_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"pendingNotifications"];
  }
  {
    SEL s = @selector(process_deleteNotification_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"deleteNotification"];
  }
  {
    SEL s = @selector(process_questionMatching_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"questionMatching"];
  }
  {
    SEL s = @selector(process_relationship_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"relationship"];
  }
  {
    SEL s = @selector(process_tagInterested_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"tagInterested"];
  }
  {
    SEL s = @selector(process_closeIntro_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"closeIntro"];
  }
  return self;
}

- (id<QAforumService>) service
{
  return [[mService retain] autorelease];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getTequilaTokenForQAforum_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getTequilaTokenForQAforum_args * args = [[getTequilaTokenForQAforum_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetTequilaTokenForQAforum_result * result = [[GetTequilaTokenForQAforum_result alloc] init];
  [result setSuccess: [mService getTequilaTokenForQAforum]];
  [outProtocol writeMessageBeginWithName: @"getTequilaTokenForQAforum"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSessionid_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getSessionid_args * args = [[getSessionid_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetSessionid_result * result = [[GetSessionid_result alloc] init];
  [result setSuccess: [mService getSessionid: [args token]]];
  [outProtocol writeMessageBeginWithName: @"getSessionid"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateSetting_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  updateSetting_args * args = [[updateSetting_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  UpdateSetting_result * result = [[UpdateSetting_result alloc] init];
  [result setSuccess: [mService updateSetting: [args setting]]];
  [outProtocol writeMessageBeginWithName: @"updateSetting"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_acceptNotif_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  acceptNotif_args * args = [[acceptNotif_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  AcceptNotif_result * result = [[AcceptNotif_result alloc] init];
  [result setSuccess: [mService acceptNotif: [args accept]]];
  [outProtocol writeMessageBeginWithName: @"acceptNotif"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_askQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  askQuestion_args * args = [[askQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  AskQuestion_result * result = [[AskQuestion_result alloc] init];
  [result setSuccess: [mService askQuestion: [args ask]]];
  [outProtocol writeMessageBeginWithName: @"askQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_answerQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  answerQuestion_args * args = [[answerQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  AnswerQuestion_result * result = [[AnswerQuestion_result alloc] init];
  [result setSuccess: [mService answerQuestion: [args answer]]];
  [outProtocol writeMessageBeginWithName: @"answerQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_feedbackQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  feedbackQuestion_args * args = [[feedbackQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  FeedbackQuestion_result * result = [[FeedbackQuestion_result alloc] init];
  [result setSuccess: [mService feedbackQuestion: [args feedback]]];
  [outProtocol writeMessageBeginWithName: @"feedbackQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_requestQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  requestQuestion_args * args = [[requestQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  RequestQuestion_result * result = [[RequestQuestion_result alloc] init];
  [result setSuccess: [mService requestQuestion: [args request]]];
  [outProtocol writeMessageBeginWithName: @"requestQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_reportQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  reportQuestion_args * args = [[reportQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  ReportQuestion_result * result = [[ReportQuestion_result alloc] init];
  [result setSuccess: [mService reportQuestion: [args report]]];
  [outProtocol writeMessageBeginWithName: @"reportQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_requestInformation_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  requestInformation_args * args = [[requestInformation_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  RequestInformation_result * result = [[RequestInformation_result alloc] init];
  [result setSuccess: [mService requestInformation: [args sessionid]]];
  [outProtocol writeMessageBeginWithName: @"requestInformation"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_myQuestions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  myQuestions_args * args = [[myQuestions_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MyQuestions_result * result = [[MyQuestions_result alloc] init];
  [result setSuccess: [mService myQuestions: [args userid]]];
  [outProtocol writeMessageBeginWithName: @"myQuestions"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_oneQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  oneQuestion_args * args = [[oneQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  OneQuestion_result * result = [[OneQuestion_result alloc] init];
  [result setSuccess: [mService oneQuestion: [args questionid]]];
  [outProtocol writeMessageBeginWithName: @"oneQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_myAnswers_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  myAnswers_args * args = [[myAnswers_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MyAnswers_result * result = [[MyAnswers_result alloc] init];
  [result setSuccess: [mService myAnswers: [args userid]]];
  [outProtocol writeMessageBeginWithName: @"myAnswers"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_oneAnswer_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  oneAnswer_args * args = [[oneAnswer_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  OneAnswer_result * result = [[OneAnswer_result alloc] init];
  [result setSuccess: [mService oneAnswer: [args forwardid]]];
  [outProtocol writeMessageBeginWithName: @"oneAnswer"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_latestQuestions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  latestQuestions_args * args = [[latestQuestions_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LatestQuestions_result * result = [[LatestQuestions_result alloc] init];
  [result setSuccess: [mService latestQuestions: [args userid]]];
  [outProtocol writeMessageBeginWithName: @"latestQuestions"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_oneLatestQuestion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  oneLatestQuestion_args * args = [[oneLatestQuestion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  OneLatestQuestion_result * result = [[OneLatestQuestion_result alloc] init];
  [result setSuccess: [mService oneLatestQuestion: [args onelatest]]];
  [outProtocol writeMessageBeginWithName: @"oneLatestQuestion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_pendingNotifications_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  pendingNotifications_args * args = [[pendingNotifications_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  PendingNotifications_result * result = [[PendingNotifications_result alloc] init];
  [result setSuccess: [mService pendingNotifications: [args userid]]];
  [outProtocol writeMessageBeginWithName: @"pendingNotifications"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_deleteNotification_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  deleteNotification_args * args = [[deleteNotification_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  DeleteNotification_result * result = [[DeleteNotification_result alloc] init];
  [result setSuccess: [mService deleteNotification: [args deleteinfo]]];
  [outProtocol writeMessageBeginWithName: @"deleteNotification"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_questionMatching_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  questionMatching_args * args = [[questionMatching_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  QuestionMatching_result * result = [[QuestionMatching_result alloc] init];
  [result setSuccess: [mService questionMatching: [args question]]];
  [outProtocol writeMessageBeginWithName: @"questionMatching"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_relationship_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  relationship_args * args = [[relationship_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  Relationship_result * result = [[Relationship_result alloc] init];
  [result setSuccess: [mService relationship: [args relation]]];
  [outProtocol writeMessageBeginWithName: @"relationship"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_tagInterested_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  tagInterested_args * args = [[tagInterested_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  TagInterested_result * result = [[TagInterested_result alloc] init];
  [result setSuccess: [mService tagInterested: [args taguser]]];
  [outProtocol writeMessageBeginWithName: @"tagInterested"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_closeIntro_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  closeIntro_args * args = [[closeIntro_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  CloseIntro_result * result = [[CloseIntro_result alloc] init];
  [result setSuccess: [mService closeIntro: [args userid]]];
  [outProtocol writeMessageBeginWithName: @"closeIntro"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) dealloc
{
  [mService release];
  [mMethodMap release];
  [super dealloc];
}

@end

